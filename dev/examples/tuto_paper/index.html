<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multisite daily Stochastic Weather Generator ¬∑ StochasticWeatherGenerators</title><meta name="title" content="Multisite daily Stochastic Weather Generator ¬∑ StochasticWeatherGenerators"/><meta property="og:title" content="Multisite daily Stochastic Weather Generator ¬∑ StochasticWeatherGenerators"/><meta property="twitter:title" content="Multisite daily Stochastic Weather Generator ¬∑ StochasticWeatherGenerators"/><meta name="description" content="Documentation for StochasticWeatherGenerators."/><meta property="og:description" content="Documentation for StochasticWeatherGenerators."/><meta property="twitter:description" content="Documentation for StochasticWeatherGenerators."/><meta property="og:url" content="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><meta property="twitter:url" content="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><link rel="canonical" href="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="StochasticWeatherGenerators logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StochasticWeatherGenerators</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">StochasticWeatherGenerators.jl</a></li><li class="is-active"><a class="tocitem" href>Multisite daily Stochastic Weather Generator</a><ul class="internal"><li><a class="tocitem" href="#Set-up"><span>Set up</span></a></li><li><a class="tocitem" href="#HMM-Hyperparameters"><span>HMM Hyperparameters</span></a></li><li><a class="tocitem" href="#Data"><span>Data</span></a></li><li><a class="tocitem" href="#Fit-the-seasonal-HMM"><span>Fit the seasonal HMM</span></a></li><li><a class="tocitem" href="#Adding-Rain-amounts-to-the-model"><span>Adding Rain amounts to the model</span></a></li><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li><li><a class="tocitem" href="#Results"><span>Results</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Multisite daily Stochastic Weather Generator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multisite daily Stochastic Weather Generator</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dmetivie/StochasticWeatherGenerators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dmetivie/StochasticWeatherGenerators.jl/blob/master/examples/tuto_paper.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multisite-daily-Stochastic-Weather-Generator"><a class="docs-heading-anchor" href="#Multisite-daily-Stochastic-Weather-Generator">Multisite daily Stochastic Weather Generator</a><a id="Multisite-daily-Stochastic-Weather-Generator-1"></a><a class="docs-heading-anchor-permalink" href="#Multisite-daily-Stochastic-Weather-Generator" title="Permalink"></a></h1><p>This tutorial describes the Stochastic Weather Generator described in the paper <em>Interpretable Seasonal Hidden Markov Model for spatio-temporal stochastic rain generation in France</em> by <a href="http://www.cmap.polytechnique.fr/~gobet/">Emmanuel Gobet</a> (CMAP - √âcole Polytechnique), <a href="https://davidmetivier.mistea.inrae.fr/">David M√©tivier</a> (MISTEA ‚Äì INRAE) and <a href="https://fr.linkedin.com/in/sylvie-parey-60285194">Sylvie Parey</a> (R&amp;D ‚Äì EDF). The paper is <strong>available</strong> on <a href="https://hal.inrae.fr/hal-04621349">HAL at this link</a>. It provides a step-by-step construction of the Seasonal Hidden Markov Model (SHMM), the interpretation of the hidden states as Weather regimes over France and eventually the validation of the model with simulations. <img src="https://github.com/dmetivie/StochasticWeatherGenerators.jl/assets/46794064/5fe1d677-877d-4fd5-83ac-29d30f728ca5" alt="Schematic of the Seasonal Hidden Markov Model"/></p><h2 id="Set-up"><a class="docs-heading-anchor" href="#Set-up">Set up</a><a id="Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up" title="Permalink"></a></h2><h3 id="Package-and-functions"><a class="docs-heading-anchor" href="#Package-and-functions">Package and functions</a><a id="Package-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Package-and-functions" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">For Julia new user</header><div class="admonition-body"><p>There are several ways to <code>add</code> a package before <code>using</code>, one way is for this tutorial to copy-paste (it might take a while):</p><pre><code class="language-julia hljs">import Pkg
Pkg.add([&quot;CSV&quot;, &quot;JLD&quot;, &quot;DelimitedFiles&quot;, &quot;DataFrames&quot;, &quot;DataFramesMeta&quot;, &quot;StatsBase&quot;, &quot;Random&quot;, &quot;Distributions&quot;, &quot;StatsPlots&quot;, &quot;LaTeXStrings&quot;])</code></pre></div></div><pre><code class="language-julia hljs">using CSV, JLD, DelimitedFiles # File Read/Load/Save

using DataFrames, DataFramesMeta # DataFrames

using Dates

using StatsBase, Random

using Distributions</code></pre><p>The two main packages for this tutorial are not yet registered in the official Julia registry, since they are not quite fully ready. They can be either <code>add</code>ed through <a href="https://github.com/dmetivie/LocalRegistry">my local Julia registry</a> with the <a href="https://github.com/GunnarFarneback/LocalRegistry.jl">LocalRegistry.jl</a> package i.e.</p><pre><code class="language-julia hljs">using LocalRegistry
using Pkg
pkg&quot;registry add https://github.com/dmetivie/LocalRegistry&quot;
Pkg.add(&quot;SmoothPeriodicStatsModels&quot;)
Pkg.add(&quot;StochasticWeatherGenerators&quot;)</code></pre><p>Or directly on the master branch with <code>add</code>ed via url i.e.</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(url = &quot;https://github.com/dmetivie/SmoothPeriodicStatsModels.jl&quot;)
Pkg.add(url = &quot;https://github.com/dmetivie/StochasticWeatherGenerators.jl&quot;)</code></pre><pre><code class="language-julia hljs">using SmoothPeriodicStatsModels # Name might change. Small collection of smooth periodic models e.g. AR, HMM

using StochasticWeatherGenerators # interface to use with SmoothPeriodicStatsModels.jl</code></pre><pre><code class="language-julia hljs">Random.seed!(1234)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.TaskLocalRNG()</code></pre><h3 id="Settings-for-plotting"><a class="docs-heading-anchor" href="#Settings-for-plotting">Settings for plotting</a><a id="Settings-for-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Settings-for-plotting" title="Permalink"></a></h3><p>Some settings and packages to have nice plots.</p><pre><code class="language-julia hljs">using StatsPlots, LaTeXStrings
using StatsPlots.PlotMeasures # To play with margin in Plots

gr() # plotly() # for interactive plots
default(fontfamily=&quot;Computer Modern&quot;)
cur_colors = get_color_palette(:auto, 100);
my_palette(K) = palette(vcat(cur_colors[1], [cur_colors[c] for c in 3:4], cur_colors[2]), K)

file_for_plot_utilities = download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/examples/utilities_plot.jl&quot;)
include(file_for_plot_utilities)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cyclic (generic function with 1 method)</code></pre><p>To plot maps, we use <code>GeoMakie.jl</code> + a hack with <code>NaturalEarth.jl</code>. This is still experimental. Note that using <code>cartopy</code> with <code>PyCall.jl</code> also works very well.</p><p>For the following code to work you will need to add the following packages</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(&quot;HTTP&quot;, &quot;JSON3&quot;, &quot;GeoMakie&quot;, &quot;CairoMakie&quot;)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Since a very recent update there is a bug in the map plot. TODO: Fix it</p></div></div><pre><code class="language-julia hljs">file_for_maps_with_geomakie = download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/examples/utilities_geo_makie_features.jl&quot;) # download file from a GitHub repo
include(file_for_maps_with_geomakie)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">map_with_stations (generic function with 3 methods)</code></pre><h3 id="Global-Parameters"><a class="docs-heading-anchor" href="#Global-Parameters">Global Parameters</a><a id="Global-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Parameters" title="Permalink"></a></h3><p>Number of days in a year (choice here is 366)</p><pre><code class="language-julia hljs">T = 366</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">366</code></pre><p>Define the French area for map (Longitude and latitude) plot and the precision of the map <code>precision_scale</code></p><pre><code class="language-julia hljs">precision_scale = &quot;50m&quot;

LON_min = -5 # West

LON_max = 10 # East

LAT_min = 41 # South

LAT_max = 52 # North</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">52</code></pre><p><code>conversion_factor</code> for rain amounts <code>RR</code> in 0.1 mm to mm</p><pre><code class="language-julia hljs">conversion_factor = 0.1 # 0.1 mm -&gt; mm</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.1</code></pre><h2 id="HMM-Hyperparameters"><a class="docs-heading-anchor" href="#HMM-Hyperparameters">HMM Hyperparameters</a><a id="HMM-Hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#HMM-Hyperparameters" title="Permalink"></a></h2><p>Number of hidden states</p><pre><code class="language-julia hljs">K = 4

my_pal = my_palette(K); # just colors I like for plotting weather regime!</code></pre><p>Degree <code>ùêÉùêûùê†</code> of the trigonometric expansion It could be an array different for each station and variable. Not implemented yet though.</p><pre><code class="language-julia hljs">ùêÉùêûùê† = 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>Local memory order i.e. at station <span>$j$</span>, <span>$\mathbb{P}(Y_n^{(j)} = y_n^{(j)} \mid Z = k, Y_{n-1:n-\texttt{local memory}}^{(j)} = y_{n-1:n-\texttt{local memory}}^{(j)})$</span></p><pre><code class="language-julia hljs">local_order = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>local_order</code> could be a vector/matrix of size <code>D</code> and different for each station, and also different depending on wet or dry past. Not yet implemented.</p></div></div><pre><code class="language-julia hljs">size_order = 2^local_order

println(&quot;K = $K, &quot;, &quot;local_order = $local_order, &quot;, &quot;degree = $ùêÉùêûùê†&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">K = 4, local_order = 1, degree = 2</code></pre><h2 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h2><h3 id="Select-relevant-stations-from-the-station.txt-file"><a class="docs-heading-anchor" href="#Select-relevant-stations-from-the-station.txt-file">Select relevant stations from the <code>station.txt</code> file</a><a id="Select-relevant-stations-from-the-station.txt-file-1"></a><a class="docs-heading-anchor-permalink" href="#Select-relevant-stations-from-the-station.txt-file" title="Permalink"></a></h3><p>Here we</p><ul><li>Remove white space at the right of the <code>CN</code>, STANAME which is caused by imperfect CVS importation</li><li>Select only the stations with 100% valid data for the period <code>Date(1955,12,31) .‚â§ :DATE .‚â§ Date(2019,12,31)</code></li><li>Shorten station names</li></ul><pre><code class="language-julia hljs">begin
    station_file = Base.download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/weather_files/stations.txt&quot;)
    station_all = CSV.read(station_file, DataFrame, header=18, normalizenames=true, ignoreemptyrows=true)
    station_all = @chain station_all begin
        @transform(:CN = rstrip.(:CN), :STANAME = rstrip.(:STANAME))
        # @subset(:CN .‚àà tuple([&quot;FR&quot;, &quot;BE&quot;, &quot;LU&quot;, &quot;CH&quot;])) # Choose that if you want to look at all stations in France, Belgium, Luxembourg and Switzerland.
        @subset(:STAID .‚àà tuple([32, 33, 34, 36, 39, 203, 322, 323, 434, 736, 737, 738, 740, 742, 745, 749, 750, 755, 756, 757, 758, 786, 793, 2192, 2203, 2205, 2207, 2209, 11244, 11245, 11247, 11249]))
        @transform(:STANAME = shortname.(:STANAME))
    end
end

selected_station_name = [&quot;BOURGES&quot;, &quot;TOULOUSE&quot;, &quot;MARIGNANE&quot;, &quot;LUXEMBOURG&quot;, &quot;LILLE&quot;, &quot;EMBRUN&quot;, &quot;BASTIA&quot;, &quot;LA HAGUE&quot;, &quot;CHASSIRON&quot;, &quot;ORLY&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{String}:
 &quot;BOURGES&quot;
 &quot;TOULOUSE&quot;
 &quot;MARIGNANE&quot;
 &quot;LUXEMBOURG&quot;
 &quot;LILLE&quot;
 &quot;EMBRUN&quot;
 &quot;BASTIA&quot;
 &quot;LA HAGUE&quot;
 &quot;CHASSIRON&quot;
 &quot;ORLY&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Hypothesis: Conditional Independence of Rain Occurrences</header><div class="admonition-body"><p>You can change the selected stations. However, keep in mind that for the model to work, the <strong>conditional independence hypothesis</strong> must hold between stations i.e. <span>$\mathbb{P}(Y_1 = y_1, \cdots, Y_S = y_s\mid Z = k) = \prod_{s=1}^S \mathbb{P}(Y_s = y_s)$</span>. Hence stations must be sufficiently far apart. Check out this <a href="https://dmetivie.github.io/ExpectationMaximization.jl/dev/examples/#MNIST-dataset:-Bernoulli-Mixture">MNIST example</a> to see Bernoulli mixtures in action!</p></div></div><pre><code class="language-julia hljs">station = @subset(station_all, :STANAME .‚àà tuple(selected_station_name))

STAID = station.STAID #[32, 33, 39, 203, 737, 755, 758, 793, 11244, 11249];

station_name = station.STANAME</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{SubString{String}}:
 &quot;BOURGES&quot;
 &quot;TOULOUSE&quot;
 &quot;MARIGNANE&quot;
 &quot;LUXEMBOURG&quot;
 &quot;LILLE&quot;
 &quot;EMBRUN&quot;
 &quot;BASTIA&quot;
 &quot;LA HAGUE&quot;
 &quot;CHASSIRON&quot;
 &quot;ORLY&quot;</code></pre><p>Sort stations (index) by latitude. It is useful for plotting from North to South.</p><pre><code class="language-julia hljs">staid_lat = sortperm(station.LAT, rev=true);</code></pre><p>Station number</p><pre><code class="language-julia hljs">D = length(STAID)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10</code></pre><h3 id="Date-range"><a class="docs-heading-anchor" href="#Date-range">Date range</a><a id="Date-range-1"></a><a class="docs-heading-anchor-permalink" href="#Date-range" title="Permalink"></a></h3><pre><code class="language-julia hljs">date_start = Date(1956)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1956-01-01</code></pre><p>Date including the previous days used in the initial condition (in case <code>local_memory &gt; 0</code>)</p><pre><code class="language-julia hljs">date_start_w_memory = date_start - Day(local_order)

date_end = Date(2020) - Day(1)

every_year = date_start:Day(1):date_end

every_year_w_memory = date_start_w_memory:Day(1):date_end

n2t = dayofyear_Leap.(every_year)

N = length(n2t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">23376</code></pre><h3 id="Treat-data"><a class="docs-heading-anchor" href="#Treat-data">Treat data</a><a id="Treat-data-1"></a><a class="docs-heading-anchor-permalink" href="#Treat-data" title="Permalink"></a></h3><p>Load into a <code>DataFrame</code> the (ECA) RR files (rain). It filters by date and valid data. It also adds a column <code>:bin</code> for rain events (0: dry, 1: wet).</p><pre><code class="language-julia hljs">begin
    data_stations = collect_data_ECA.(STAID, date_start_w_memory, date_end, &quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/weather_files/ECA_blend_rr/RR_&quot;, portion_valid_data=1, skipto=22, header=21, url=true)
    for i = eachindex(data_stations)
        @transform!(data_stations[i], :bin = onefy.(:RR))
    end
end</code></pre><p>Binary matrix version of the rain event at the <code>D</code> stations.</p><pre><code class="language-julia hljs">Yall = BitMatrix(reduce(hcat, [data_stations[j].bin for j = 1:D]))

Y_past = BitMatrix(Yall[1:local_order, :]) # rand(Bool, local_order, D)

Œæ = [1; zeros(K - 1)];  # 1 jan 1956 was most likely a type Z = 1 wet day all over France

Y = Yall[1+local_order:end, :]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">23376√ó10 BitMatrix:
 1  1  1  1  1  1  1  1  1  1
 1  1  0  1  1  0  1  0  1  0
 0  0  0  0  0  0  1  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  1  1  0  0  0  0  0  0  1
 1  1  1  0  1  0  1  1  1  1
 1  1  1  1  1  1  0  0  1  1
 0  1  1  1  1  1  1  1  1  0
 1  0  0  1  1  1  0  1  1  1
 ‚ãÆ              ‚ãÆ           
 1  1  0  1  1  1  0  1  1  1
 1  0  0  1  1  0  0  0  0  0
 0  0  0  1  0  0  0  1  1  0
 1  0  0  1  1  0  0  1  0  1
 1  0  0  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  1  0
 0  0  0  0  1  0  0  0  1  0
 0  0  0  0  0  0  0  0  1  0
 0  0  0  0  0  0  0  0  1  0</code></pre><h3 id="Map-of-stations"><a class="docs-heading-anchor" href="#Map-of-stations">Map of stations</a><a id="Map-of-stations-1"></a><a class="docs-heading-anchor-permalink" href="#Map-of-stations" title="Permalink"></a></h3><p>Convert LAT/LON coordinates from DMS to DD which seems most widely accepted format.</p><pre><code class="language-julia hljs">LAT_idx = dms_to_dd.(station.LAT)

LON_idx = dms_to_dd.(station.LON)

long_spell = [longuest_spell(y) for y in eachcol(Y)]

# map_with_stations(LON_idx, LAT_idx, long_spell; station_name=station_name, show_value=true, colorbar_show=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Int64}:
 36
 34
 60
 33
 33
 57
 59
 39
 32
 38</code></pre><h2 id="Fit-the-seasonal-HMM"><a class="docs-heading-anchor" href="#Fit-the-seasonal-HMM">Fit the seasonal HMM</a><a id="Fit-the-seasonal-HMM-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-the-seasonal-HMM" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Hypothesis: Smooth parameter evolution</header><div class="admonition-body"><p>We assume all models e.g. HMM, rain mixture to have parameters evolving smoothly with periodicity <span>$T$</span> for <span>$t \in [1, T]$</span>. For example a Bernoulli parameter will write</p><p class="math-container">\[p(t) = \dfrac{1}{1 + e^{P(t)}} \in [0, 1],\]</p><p>with</p><p class="math-container">\[    P_c(t) = c_0 + \sum_{j=1}^{\texttt{Deg}} \left(c_{2j-1}\cos\left(\dfrac{2\pi}{T}j t\right) + c_{2j}\sin\left(\dfrac{2\pi}{T}j t\right)\right).\]</p></div></div><h3 id="Fit-slice:-naive-estimation"><a class="docs-heading-anchor" href="#Fit-slice:-naive-estimation">Fit slice: naive estimation</a><a id="Fit-slice:-naive-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-slice:-naive-estimation" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Before inferring the HMM parameters with the EM (Baum-Welch) algorithm, we do a first naive inference that will be used as initial condition for the EM.</p></div></div><p>The reference station <code>ref_station</code> is used to sort the hidden states obtained via the slide initialization Here we choose <code>j=1</code> <span>$\to$</span> <code>STAID=32</code> <span>$\to$</span> <code>BOURGES</code> because it is a central station for France</p><pre><code class="language-julia hljs">ref_station = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>This generates a random Periodic HMM that we then fit slice by slice (day by day). See paper.</p><pre><code class="language-julia hljs">hmm_random = randhierarchicalPeriodicHMM(K, T, D, local_order; Œæ=Œæ, ref_station=ref_station);

@time &quot;FitMLE SHMM (Slice)&quot; hmm_slice = fit_mle_all_slices(hmm_random, Y, Y_past; n2t=n2t, robust=true, rand_ini=true, Dirichlet_Œ±=0.8, history=false, n_random_ini=1, Y‚Çú_extanted=[-12, -7, 0, 6, 13]);

Œ∏·¥¨_slice, Œ∏·¥Æ_slice = fit_Œ∏!(hmm_slice, ùêÉùêûùê†);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FitMLE SHMM (Slice): 26.396966 seconds (194.89 M allocations: 30.013 GiB, 8.82% gc time, 23.07% compilation time)

******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit https://github.com/coin-or/Ipopt
******************************************************************************</code></pre><h3 id="Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point"><a class="docs-heading-anchor" href="#Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point">Fit with Baum Welch using the slice estimate as a starting point</a><a id="Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point" title="Permalink"></a></h3><p>With the Slice estimate as a good starting point for the full (seasonal) Baum Welch EM algorithm we fit the model!</p><pre><code class="language-julia hljs">@time &quot;FitMLE SHMM (Baum Welch)&quot; hmm_fit, Œ∏q_fit, Œ∏y_fit, hist, histo_A, histo_B = fit_mle(hmm_slice, Œ∏·¥¨_slice, Œ∏·¥Æ_slice, Y, Y_past,
    maxiter=10000, robust=true; display=:final, silence=true, tol=1e-3, Œ∏_iters=true, n2t=n2t);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EM converged in 74 iterations, logtot = -116791.10200745627
FitMLE SHMM (Baum Welch): 62.576305 seconds (188.68 M allocations: 33.083 GiB, 7.93% gc time, 12.63% compilation time)</code></pre><p>Uncomment to load previously computed hmm</p><pre><code class="language-julia hljs"># hmm_infos = load(&quot;save_tuto_path/hmm_fit.jld&quot;)
# hmm_fit = hmm_infos[&quot;hmm&quot;]
# hist = hmm_infos[&quot;hist&quot;]
# Œ∏q_fit = hmm_infos[&quot;Q_param&quot;]
# Œ∏y_fit = hmm_infos[&quot;Y_param&quot;]</code></pre><h3 id="Visualization-of-the-HMM-parameters"><a class="docs-heading-anchor" href="#Visualization-of-the-HMM-parameters">Visualization of the HMM parameters</a><a id="Visualization-of-the-HMM-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-the-HMM-parameters" title="Permalink"></a></h3><h4 id="Transition-matrix"><a class="docs-heading-anchor" href="#Transition-matrix">Transition matrix</a><a id="Transition-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-matrix" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    pA = [plot(legendfont=14, foreground_color_legend=nothing, background_color_legend=nothing, legend_columns=4, tickfont=12, legendfontsize=16) for k in 1:K]
    for k in 1:K
        [plot!(pA[k], hmm_fit.A[k, l, :], c=my_color(l, K), label=L&quot;Q_{%$(k)\to %$(l)}&quot;, legend=:top, lw=1.75) for l in 1:K]
        hline!(pA[k], [0.5], c=:black, label=:none, s=:dot)
        xticks!(pA[k], vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366), vcat(string.(monthabbr.(1:12)), &quot;&quot;), xlims=(0, 367), ylims=(0, 1))
    end
    pallA = plot(pA..., size=(1000, 500))
end</code></pre><img src="c3eb28d9.svg" alt="Example block output"/><h4 id="Rain-probabilities"><a class="docs-heading-anchor" href="#Rain-probabilities">Rain probabilities</a><a id="Rain-probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-probabilities" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    mm = 1
    jt = D
    pB = [plot(legendfont=14, title=&quot;$(station_name[j])&quot;, titlefontsize=17, tickfont=14, legendfontsize = 14) for j in 1:jt]
    for j in 1:jt
        [plot!(pB[j], succprob.(hmm_fit.B[k, :, j, mm]), c=my_color(k, K), label=islabel(j, 3, L&quot;\mathbb{P}(Y = \textrm{wet}\mid Z = %$k, H = \textrm{dry})&quot;), lw=2) for k in 1:K]
        hline!(pB[j], [0.5], c=:black, label=:none, s=:dot)
        xticks!(
            pB[j],
            vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366),
            vcat(string.(first.(monthabbr.(1:12))))
        )
        xlims!(pB[j], (0, 367))
        ylims!(pB[j], (0, 1))
    end
    pallB = plot(pB[staid_lat]..., size=(3000 / 2, 1000 / 1), layout=(2, 5))
end</code></pre><img src="3ff6e87c.svg" alt="Example block output"/><h4 id="Spatial-Rain-probability"><a class="docs-heading-anchor" href="#Spatial-Rain-probability">Spatial Rain probability</a><a id="Spatial-Rain-probability-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-Rain-probability" title="Permalink"></a></h4><pre><code class="language-julia hljs">memory_past_cat = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>h = 1 (day before dry) or 2 (day before wet) <span>$\mathbb{P}(Y = \text{Rain}\mid Z = k, H = h)$</span> with <code>h = memory_past_cat</code></p><h3 id="Inference-of-the-historical-hidden-states"><a class="docs-heading-anchor" href="#Inference-of-the-historical-hidden-states">Inference of the historical hidden states</a><a id="Inference-of-the-historical-hidden-states-1"></a><a class="docs-heading-anchor-permalink" href="#Inference-of-the-historical-hidden-states" title="Permalink"></a></h3><h4 id="Viterbi-algorithm"><a class="docs-heading-anchor" href="#Viterbi-algorithm">Viterbi algorithm</a><a id="Viterbi-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Viterbi-algorithm" title="Permalink"></a></h4><pre><code class="language-julia hljs">zÃÇ = viterbi(hmm_fit, Y, Y_past; n2t=n2t)

data_stations_z = map(data_stations) do df
    @transform(df, :z = [fill(missing, local_order); zÃÇ])
end

zÃÇ_per_cat = [findall(zÃÇ .== k) for k in 1:K]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Int64}}:
 [1, 7, 8, 12, 17, 23, 29, 44, 80, 81  ‚Ä¶  23356, 23357, 23358, 23359, 23362, 23364, 23365, 23366, 23367, 23368]
 [2, 10, 11, 14, 18, 20, 21, 22, 25, 26  ‚Ä¶  23323, 23327, 23328, 23333, 23351, 23352, 23355, 23360, 23361, 23371]
 [6, 9, 15, 16, 27, 30, 31, 40, 41, 45  ‚Ä¶  23325, 23330, 23331, 23332, 23334, 23335, 23339, 23345, 23346, 23363]
 [3, 4, 5, 13, 19, 24, 32, 33, 34, 38  ‚Ä¶  23348, 23349, 23350, 23369, 23370, 23372, 23373, 23374, 23375, 23376]</code></pre><h4 id="Visualization-of-the-historical-sequences-of-hidden-states"><a class="docs-heading-anchor" href="#Visualization-of-the-historical-sequences-of-hidden-states">Visualization of the historical sequences of hidden states</a><a id="Visualization-of-the-historical-sequences-of-hidden-states-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-the-historical-sequences-of-hidden-states" title="Permalink"></a></h4><pre><code class="language-julia hljs">year_range = unique(year.(data_stations[1][1+local_order:end, :DATE]));

idx_year = [findall(x -&gt; year.(x) == m, data_stations[1][1+local_order:end, :DATE]) for m in year_range];

select_year = unique(sort([4:10:length(year_range); 21; 48; 64]))

begin
    year_nb = length(select_year)
    z_hat_mat = zeros(year_nb, 366)

    for (i, y) in enumerate(select_year)
        if isleapyear(year_range[y])
            z_hat_mat[i, :] = zÃÇ[idx_year[y]]
        else
            z_hat_mat[i, :] = [zÃÇ[idx_year[y]]; 0]
        end
    end
    thick = 1
    heatmap(z_hat_mat, colorbar=:none, c=my_palette(K), minorticks=:false, framestyle=:xbox, grid=:none, thickness_scaling=thick)
    xticks!(vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366), vcat(string.(monthabbr.(1:12)), &quot;&quot;), xlims=(0, 367), xtickfontsize=14 / thick, ytickfontsize=14 / thick)
    hline!((1:year_nb) .+ 0.5, c=:black, legend=:none, lw=4)
    ylims!(0.5, year_nb + 0.5)
    pviterbi = yticks!(1:year_nb, string.(year_range[select_year]), size=(1000, 600))
end</code></pre><img src="ce7edd2a.svg" alt="Example block output"/><h2 id="Adding-Rain-amounts-to-the-model"><a class="docs-heading-anchor" href="#Adding-Rain-amounts-to-the-model">Adding Rain amounts to the model</a><a id="Adding-Rain-amounts-to-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Rain-amounts-to-the-model" title="Permalink"></a></h2><h3 id="Marginal-distribution"><a class="docs-heading-anchor" href="#Marginal-distribution">Marginal distribution</a><a id="Marginal-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Marginal-distribution" title="Permalink"></a></h3><p>We fit the marginals of the rain amount <span>$R&gt;0$</span> at each station <span>$s$</span> and for each hidden state <span>$Z$</span> independently. We use a mixture of exponential functions</p><p class="math-container">\[g(r) = w \dfrac{e^{-{\frac {r}{\vartheta_1}}}}{\vartheta_1} + (1-w)  \dfrac{e^{-{\frac {r}{\vartheta_2}}}}{\vartheta_2}.\]</p><p>whose parameters <span>$w(t)$</span>, <span>$\vartheta_1(t)$</span> and <span>$\vartheta_2(t)$</span> are smooth periodic functions of the day of the year.</p><pre><code class="language-julia hljs">@time &quot;FitMLE RR&quot; mix_allE = fit_mle_RR.(data_stations_z, K, local_order, mix‚ÇÄ=StochasticWeatherGenerators.mix_ini(T));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FitMLE RR: 93.888089 seconds (335.87 M allocations: 47.641 GiB, 4.08% gc time, 4.89% compilation time)</code></pre><p>Thanks to <a href="https://github.com/JuliaStats/Distributions.jl/pull/1389">Distributions.jl PR #1389 (September 2nd, 2021)</a> and Julia multiple dispatch, the quantile function of Mixtures can be very efficiently computed.</p><h3 id="Rain-correlations"><a class="docs-heading-anchor" href="#Rain-correlations">Rain correlations</a><a id="Rain-correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-correlations" title="Permalink"></a></h3><p>We fit a Gaussian copula to each pair of stations for joint rainy days only.</p><p>!!! warning   For some hidden states corresponding to dry weather, it might happen that for some pair of stations, there are no simultaneous rain occurrences in a rain category <span>$Z = k$</span>.   In that case a <code>missing</code> coefficient is returned.</p><pre><code class="language-julia hljs">begin
    Œ£¬≤RR = cov_RR(data_stations_z, K)
    if K == 4
        Œ£¬≤RR[2][6, 3] = Œ£¬≤RR[4][6, 3]
        Œ£¬≤RR[2][3, 6] = Œ£¬≤RR[4][6, 3]
    end
    Œ£¬≤RR = convert.(Matrix{Float64}, Œ£¬≤RR)
end

if K == 4
    @warn &quot;For Embrun j=6 and Marignane j=3 the hidden state Z=2 and Z=4 are pretty similar (dry), so we replace the `missing` coefficient of Z=2 with the one of Z = 4&quot;
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">‚îå Warning: Œ£S_k[2], CartesianIndex{2}[CartesianIndex(6, 3), CartesianIndex(3, 6)] are missing
‚îî @ StochasticWeatherGenerators ~/work/StochasticWeatherGenerators.jl/StochasticWeatherGenerators.jl/src/rain/correlations.jl:80
‚îå Warning: For Embrun j=6 and Marignane j=3 the hidden state Z=2 and Z=4 are pretty similar (dry), so we replace the `missing` coefficient of Z=2 with the one of Z = 4
‚îî @ Main tuto_paper.md:456</code></pre><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><p>Now we are ready to generate samples from the SWG model.</p><p><code>Nb</code> is the number of realization</p><pre><code class="language-julia hljs">Nb = 1000</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000</code></pre><p>Sample the (seasonal) HMM model and output the sequence of hidden states and multi-site dry/wet.</p><pre><code class="language-julia hljs">begin
    zs = zeros(Int, N, Nb)
    ys = zeros(Bool, N, D, Nb)
    @time &quot;Simulations Z, Y&quot; for i in 1:Nb
        zs[:, i], ys[:, :, i] = rand(hmm_fit, n2t; y_ini=Yall[1:local_order, :], z_ini=1, seq=true)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulations Z, Y: 61.258844 seconds (328.74 M allocations: 32.194 GiB, 7.77% gc time, 1.35% compilation time)</code></pre><p>Given the hidden states and dry/wet, it generates the rain amounts at each station (correlated with a Gaussian Copula).</p><pre><code class="language-julia hljs">begin
    rs = zeros(D, N, Nb)
    @time &quot;Simulations RR&gt;0&quot; for i in 1:Nb
        rs[:, :, i] = rand_RR(mix_allE, n2t, zs[:, i], ys[:, :, i]&#39;, Œ£¬≤RR)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulations RR&gt;0: 237.014362 seconds (285.46 M allocations: 37.953 GiB, 1.24% gc time, 0.73% compilation time)</code></pre><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><h3 id="Spell-distribution"><a class="docs-heading-anchor" href="#Spell-distribution">Spell distribution</a><a id="Spell-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Spell-distribution" title="Permalink"></a></h3><p><code>select_month</code> to choose the month where to compute the spell distributions (summer month, winter, etc.) <code>select_month = 1:12</code> corresponds to all months.</p><pre><code class="language-julia hljs">select_month = 1:12

idx_months = [findall(x -&gt; month.(x) == m, data_stations[1][1+local_order:end, :DATE]) for m in 1:12]

idx_month_vcat = vcat(idx_months[select_month]...)

idx_all = [intersect(yea, mon) for yea in idx_year, mon in idx_months];</code></pre><h5 id="Historic-spells"><a class="docs-heading-anchor" href="#Historic-spells">Historic spells</a><a id="Historic-spells-1"></a><a class="docs-heading-anchor-permalink" href="#Historic-spells" title="Permalink"></a></h5><pre><code class="language-julia hljs">len_spell_hist = [pmf_spell(Y[idx_month_vcat, j], dw) for j in 1:D, dw in 0:1];</code></pre><h5 id="Simulation-spells"><a class="docs-heading-anchor" href="#Simulation-spells">Simulation spells</a><a id="Simulation-spells-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-spells" title="Permalink"></a></h5><pre><code class="language-julia hljs">len_spell_simu = [pmf_spell(ys[idx_month_vcat, j, i], dw) for i in 1:Nb, j in 1:D, dw in 0:1];</code></pre><h4 id="Dry-spell"><a class="docs-heading-anchor" href="#Dry-spell">Dry spell</a><a id="Dry-spell-1"></a><a class="docs-heading-anchor-permalink" href="#Dry-spell" title="Permalink"></a></h4><pre><code class="language-julia hljs">make_range(y, step=1) = range(extrema(y)..., step=step)

begin
    dry_or_wet = 1 # dry
    p_spell_dry = [plot(ylims=(1e-4, 1e-0), tickfont=11, legendfontsize=13) for j = 1:D]
    for j = 1:D
        all_spells = len_spell_simu[:, j, dry_or_wet]
        errorlinehist!(p_spell_dry[j], all_spells, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median)

        errorlinehist!(p_spell_dry[j], all_spells, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median)

        histo_spell = len_spell_hist[j, dry_or_wet]
        errorlinehist!(p_spell_dry[j], [histo_spell], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:probability, bins=make_range(histo_spell), errortype=:percentile)
        xlims!(p_spell_dry[j], 0, 2 + maximum(1.5maximum.(histo_spell)))
        yaxis!(:log10)
    end

    [xlabel!(p_spell_dry[j], &quot;Nb of days&quot;, xlabelfontsize=12) for j in staid_lat[6:10]]
    [ylabel!(p_spell_dry[j], &quot;PMF&quot;, ylabelfontsize=12) for j in staid_lat[[1, 6]]]
    [title!(p_spell_dry[j], station_name[j], titlefontsize=13) for j = 1:D]
    pall_spell_dry = plot(p_spell_dry[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), left_margin=0.5cm, bottom_margin=0.275cm)
end</code></pre><img src="8ec9d3f3.svg" alt="Example block output"/><h4 id="Wet-spell"><a class="docs-heading-anchor" href="#Wet-spell">Wet spell</a><a id="Wet-spell-1"></a><a class="docs-heading-anchor-permalink" href="#Wet-spell" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    dry_or_wet = 2 # wet
    p_spell_wet = [plot(ylims=(1e-4, 1e-0), tickfont=11, legendfontsize=13) for j = 1:D]
    for j = 1:D
        all_spells = len_spell_simu[:, j, dry_or_wet]
        errorlinehist!(p_spell_wet[j], all_spells, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median)

        errorlinehist!(p_spell_wet[j], all_spells, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median)

        histo_spell = len_spell_hist[j, dry_or_wet]
        errorlinehist!(p_spell_wet[j], [histo_spell], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:probability, bins=make_range(histo_spell), errortype=:percentile)
        xlims!(p_spell_wet[j], 0, 2 + maximum(1.5maximum.(histo_spell)))
        yaxis!(:log10)
    end

    [xlabel!(p_spell_wet[j], &quot;Nb of days&quot;, xlabelfontsize=12) for j in staid_lat[6:10]]
    [ylabel!(p_spell_wet[j], &quot;PMF&quot;, ylabelfontsize=12) for j in staid_lat[[1, 6]]]
    [title!(p_spell_wet[j], station_name[j], titlefontsize=13) for j = 1:D]
    pall_spell_wet = plot(p_spell_wet[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), left_margin=0.5cm, bottom_margin=0.275cm)
end</code></pre><img src="5951351a.svg" alt="Example block output"/><h3 id="Rain"><a class="docs-heading-anchor" href="#Rain">Rain</a><a id="Rain-1"></a><a class="docs-heading-anchor-permalink" href="#Rain" title="Permalink"></a></h3><h4 id="Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k."><a class="docs-heading-anchor" href="#Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k.">Interpretation: Mean Rain per weather regime <span>$R &gt; 0 \mid Z = k$</span>.</a><a id="Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k.-1"></a><a class="docs-heading-anchor-permalink" href="#Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k." title="Permalink"></a></h4><p>We plot the empirical (strictly) positive <strong>mean</strong> rain amounts per weather regime. The results are smoothed using a <code>cyclic_moving_average</code> with a time window of <span>$\pm 15$</span> days and the Epanechnikov kernel.</p><pre><code class="language-julia hljs">begin
    p_rainpercat = [plot(tickfont=12, ylabelfontsize=14, titlefontsize=14, legendfontsize=13) for j = 1:D]
    for j = 1:D
        df_j = @chain data_stations_z[j] begin
            dropmissing
            @transform(:day = dayofyear_Leap.(:DATE))
            @subset(:RR .&gt; 0)
            @by([:day, :z], :MEAN_RR = mean(:RR))
            groupby(:z)
        end
        # Uncomment to see how the double exponential mixtures compare to the empirical data.
        # [plot!(p_rainpercat[j], 1:T, t -&gt; conversion_factor * mean(mix_allE[j][k, t]), label=:none, c=my_color(k, K), lw=1.5, legend = :topleft) for k in 1:K]
        for k in 1:K
            cycle_avg = replace(cyclic_moving_average(df_j[k].MEAN_RR, df_j[k].day, T, 15), 0 =&gt; missing)
            @df df_j[k] plot!(p_rainpercat[j], 1:T, conversion_factor * cycle_avg, c=my_color(k, K), alpha=1, label=islabel(j, staid_lat[[4]], L&quot;Z = %$k&quot;), lw=1.5)
        end
        ylims!(p_rainpercat[j], 0, Inf)
    end
    [ylabel!(p_rainpercat[j], L&quot;Rain (mm/m$^2$)&quot;) for j in staid_lat[[1, 6]]]
    [xticks!(
        p_rainpercat[j],
        vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366),
        vcat(string.(first.(string.(monthabbr.(1:12)))))
    ) for j in 1:D]
    [title!(p_rainpercat[j], station_name[j]) for j = 1:D]
    plt_rain_cat_mix = plot(p_rainpercat[staid_lat]..., size=(3000 / 2.2, 1000 / 1.5), layout=(2, 5), left_margin=25px)
end</code></pre><img src="905832a8.svg" alt="Example block output"/><h4 id="Univariate-Rain-distributions"><a class="docs-heading-anchor" href="#Univariate-Rain-distributions">Univariate Rain distributions</a><a id="Univariate-Rain-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Rain-distributions" title="Permalink"></a></h4><p>Historical vs Nb simulations distribution</p><pre><code class="language-julia hljs">begin
    p_uniR = [plot(yaxis=:log10, ylims=(1e-4, 1e-0), tickfont=11, legendfontsize=13, titlefontsize=13) for j = 1:D]
    for j = 1:D
        dists_RR_positive_j = conversion_factor * [filter(!iszero, rs[j, :, i]) for i in 1:Nb]
        errorlinehist!(p_uniR[j], dists_RR_positive_j, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:pdf, errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median)

        errorlinehist!(p_uniR[j], dists_RR_positive_j, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:pdf, errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median)

        errorlinehist!(p_uniR[j], [conversion_factor * filter(!iszero, data_stations[j].RR)], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:pdf, errortype=:percentile)

        xlims!(p_uniR[j], 0.0, Inf)
    end
    [plot!(p_uniR[j], xlabel=L&quot;Rain (mm/m$^2$)&quot;) for j in staid_lat[6:10]]
    [plot!(p_uniR[j], ylabel=&quot;PDF&quot;) for j in staid_lat[[1, 6]]]

    [title!(p_uniR[j], station_name[j]) for j = 1:D]

    pall_R = plot(p_uniR[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), bottom_margin=11px, left_margin=15px)
end</code></pre><img src="1a73e343.svg" alt="Example block output"/><h4 id="Monthly-quantile-amount"><a class="docs-heading-anchor" href="#Monthly-quantile-amount">Monthly quantile amount</a><a id="Monthly-quantile-amount-1"></a><a class="docs-heading-anchor-permalink" href="#Monthly-quantile-amount" title="Permalink"></a></h4><pre><code class="language-julia hljs">rh = reduce(hcat, [df[1+local_order:end, :RR] for df in data_stations])

month_rain_simu = [cum_monthly(rs[j, :, i], idx_all) for j in 1:D, i in 1:Nb];

month_rain_histo = [cum_monthly(rh[:, j], idx_all) for j in 1:D]

qs = [0.9, 0.5, 0.1]

@time &quot;Plot monthly quantile&quot; begin
    p_month_RR = [scatter(xtickfontsize=10, ytickfontsize=11, ylabelfontsize=12, legendfontsize = 12, foreground_color_legend=nothing) for j = 1:D]
    for j = 1:D
        for (Œ±, per) in enumerate([[0, 100], [25, 75]])
            for (cc, q) in enumerate(qs)
                errorline!(p_month_RR[j], [quantile(month_rain_simu[j, i][:, m], q) * conversion_factor for m in 1:12, i in 1:Nb], label=(Œ± == 1 ? islabel(j, 9,L&quot;Simu  $q_{%$(Int(q*100))}$&quot;) : :none), fillalpha=0.18 * Œ±^2, centertype=:median, errortype=:percentile, percentiles=per, groupcolor=my_palette(length(qs))[cc])
            end
        end
        for q in qs
            scatter!(p_month_RR[j], m -&gt; quantile(month_rain_histo[j][:, m], q) * conversion_factor, 1:12, label=(q == qs[1] ? islabel(j, 3,&quot;Obs&quot;) : :none), legend = :topleft, ms=2.5, c=:blue)
            plot!(p_month_RR[j], m -&gt; quantile(month_rain_histo[j][:, m], q) * conversion_factor, 1:12, label=:none, c=:blue, lw=1.75)
        end
        xticks!(p_month_RR[j], 1:12, string.(first.(monthabbr.(1:12))))
        ylims!(p_month_RR[j], 0, Inf)
    end
    [ylabel!(p_month_RR[j], L&quot;Rain (mm/m$^2$)&quot;) for j in staid_lat[[1, 6]]]

    [title!(p_month_RR[j], station_name[j], titlefontsize=12) for j = 1:D]
    pall_month_RR = plot(p_month_RR[staid_lat]..., size=(1190, 500), layout=(2, 5), left_margin=19px)
end</code></pre><img src="4c2d4b3d.svg" alt="Example block output"/><h3 id="Correlations"><a class="docs-heading-anchor" href="#Correlations">Correlations</a><a id="Correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Correlations" title="Permalink"></a></h3><h5 id="Rain-event-dry/wet"><a class="docs-heading-anchor" href="#Rain-event-dry/wet">Rain event dry/wet</a><a id="Rain-event-dry/wet-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-event-dry/wet" title="Permalink"></a></h5><pre><code class="language-julia hljs">cor_bin_hist = cor(reduce(hcat, [df.bin for df in data_stations]));

cor_bin_mean_simu = mean(cor(ys[:, :, i]) for i in 1:Nb);


begin
    plots_cor_bin = [plot(-0.1:0.1:0.8, -0.1:0.1:0.8, aspect_ratio=true, label=:none, xlabelfontsize=16, ylabelfontsize=16, tickfont=11, legendfontsize=13) for _ in 1:1]
    scatter!(plots_cor_bin[1], vec_triu(cor_bin_hist), vec_triu(cor_bin_mean_simu), label=&quot;Correlations&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=2)
    [xlims!(plots_cor_bin[i], -0.1, 1) for i in 1:1]
    [ylims!(plots_cor_bin[i], -0.1, 1) for i in 1:1]
    annotate!(0.2, 0.7, &quot;MSE ‚âÉ $(round(mean(abs2, vec_triu(cor_bin_hist) - vec_triu(cor_bin_mean_simu)), digits = 4))&quot;)
    plot_cor_bin = plot(plots_cor_bin...)
end</code></pre><img src="dce84485.svg" alt="Example block output"/><p>The largest pair correlation error for rain occurence comes from the pair</p><pre><code class="language-julia hljs">println(&quot;$(station_name[findmax(cor_bin_hist - cor_bin_mean_simu)[2][1]]) and $(station_name[findmax(cor_bin_hist - cor_bin_mean_simu)[2][2]])&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CHASSIRON and LA HAGUE</code></pre><h5 id="Rain-amount"><a class="docs-heading-anchor" href="#Rain-amount">Rain amount</a><a id="Rain-amount-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-amount" title="Permalink"></a></h5><pre><code class="language-julia hljs">cor_hist = cor(reduce(hcat, [df.RR for df in data_stations]));

corT_hist = corTail(reduce(hcat, [df.RR for df in data_stations]));

cor_mean_simu = mean(cor(rs[:, :, i]&#39;) for i in 1:Nb);

corT_mean_simu = mean(corTail(rs[:, :, i]&#39;) for i in 1:Nb);

begin
    plots_cor = [plot(-0.1:0.1:0.8, -0.1:0.1:0.8, aspect_ratio=true, label=:none, xlabelfontsize=16, ylabelfontsize=16, tickfont=11, legendfontsize=13) for _ in 1:2]
    scatter!(plots_cor[1], vec_triu(cor_hist), vec_triu(cor_mean_simu), label=&quot;Correlations&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=2)
    annotate!(plots_cor[1], 0.3, 0.7, &quot;MSE ‚âÉ $(round(mean(abs2, vec_triu(cor_hist) - vec_triu(cor_mean_simu)), digits = 4))&quot;)

    scatter!(plots_cor[2], vec_triu(corT_hist), vec_triu(corT_mean_simu), label=&quot;Tail index&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=3)
    annotate!(plots_cor[2], 0.3, 0.7, &quot;MSE ‚âÉ $(round(mean(abs2, vec_triu(corT_hist) - vec_triu(corT_mean_simu)), digits = 4))&quot;)

    [xlims!(plots_cor[i], -0.1, 1) for i in 1:2]
    [ylims!(plots_cor[i], -0.1, 1) for i in 1:2]
    plot(plots_cor..., size=(800, 400), left_margin=15px)
end</code></pre><img src="20e3bd0d.svg" alt="Example block output"/><p>The largest pair correlation error for rain (zero and non zero amounts) comes from the pair</p><pre><code class="language-julia hljs">println(&quot;$(station_name[findmax(cor_hist - cor_mean_simu)[2][1]]) and $(station_name[findmax(cor_hist - cor_mean_simu)[2][2]])&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EMBRUN and MARIGNANE</code></pre><h5 id="Gaussian-copula-hypothesis"><a class="docs-heading-anchor" href="#Gaussian-copula-hypothesis">Gaussian copula hypothesis</a><a id="Gaussian-copula-hypothesis-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-copula-hypothesis" title="Permalink"></a></h5><p>For a pair of stations, we transform the marginal <span>$R_s&gt;0$</span> to <span>$\mathcal{N}(0,1)$</span>. We compare the obtained bi-variate Normal distribution with the Mahalanobis distance to the theoretical <span>$\chi^2(2)$</span>-distriubtion.</p><pre><code class="language-julia hljs">corŒ£ = cov2cor.(Œ£¬≤RR)
begin
    j1 = 10
    j2 = 8
    plt_qqp_copula = plot(0:25, 0:25, aspect_ratio=:equal, legendfontsize=14, c=:black, label=:none, tickfont=12, ylabelfontsize=13, xlabelfontsize=13)
    df_12 = leftjoin(data_stations_z[j1], data_stations_z[j2], on=:DATE, makeunique=true)
    @subset!(df_12, :RR .&gt; 0, :RR_1 .&gt; 0)
    for k in 1:K
        df_X = @chain df_12 begin
            @subset(:z .== k)
            dropmissing
            @aside u = StochasticWeatherGenerators.Copulas.pseudos(permutedims(hcat(_.RR, _.RR_1)))
            @transform(:X = quantile(Normal(), u[1,:]), :X_1 = quantile(Normal(), u[2,:]))
        end
        X = hcat(df_X.X, df_X.X_1)
        cor_sigma = [1 corŒ£[k][j1,j2]; corŒ£[k][j1,j2] 1]
        Œ£‚Åª¬π = inv(cor_sigma)

        X2 = [(x&#39; * Œ£‚Åª¬π * x) for x in eachrow(X)] |&gt; sort
        ecdfX2 = ecdf(X2)(X2) * length(X2) / (length(X2) + 1)

        plot!(quantile(Chisq(2), ecdfX2), X2, xlabel=L&quot;$\chi^2(2)$-quantile&quot;, c=my_color(k, K), ylabel=&quot;Observed squared Mahalanobis distance&quot;, label=L&quot;Z = %$k &quot;, legend=:topleft, lw=2)
    end
    title!(&quot;$(station_name[j1]) vs $(station_name[j2])&quot;)
    xlims!(0, 22)
    ylims!(0, 22)
end</code></pre><img src="2b018fe0.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">¬´ StochasticWeatherGenerators.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 2 July 2024 14:47">Tuesday 2 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
