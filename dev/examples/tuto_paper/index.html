<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multisite rainfall HMM based SWG (paper)  · StochasticWeatherGenerators.jl</title><meta name="title" content="Multisite rainfall HMM based SWG (paper)  · StochasticWeatherGenerators.jl"/><meta property="og:title" content="Multisite rainfall HMM based SWG (paper)  · StochasticWeatherGenerators.jl"/><meta property="twitter:title" content="Multisite rainfall HMM based SWG (paper)  · StochasticWeatherGenerators.jl"/><meta name="description" content="Documentation for StochasticWeatherGenerators.jl."/><meta property="og:description" content="Documentation for StochasticWeatherGenerators.jl."/><meta property="twitter:description" content="Documentation for StochasticWeatherGenerators.jl."/><meta property="og:url" content="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><meta property="twitter:url" content="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><link rel="canonical" href="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/table.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="StochasticWeatherGenerators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StochasticWeatherGenerators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">📘 Models</span><ul><li><a class="tocitem" href="../../models/rain/">Rainfall</a></li><li><a class="tocitem" href="../../models/others/">Temperature &amp; Others</a></li></ul></li><li><a class="tocitem" href="../../data/">📅 Weather Data</a></li><li><span class="tocitem">📎 Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Multisite rainfall HMM based SWG (paper) </a><ul class="internal"><li><a class="tocitem" href="#Set-up"><span>Set up</span></a></li><li><a class="tocitem" href="#HMM-Hyperparameters"><span>HMM Hyperparameters</span></a></li><li><a class="tocitem" href="#Data"><span>Data</span></a></li><li><a class="tocitem" href="#Fit-the-seasonal-HMM"><span>Fit the seasonal HMM</span></a></li><li><a class="tocitem" href="#Adding-Rainfall-amounts-to-the-model"><span>Adding Rainfall amounts to the model</span></a></li><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li><li><a class="tocitem" href="#TutoWGEN"><span>WGEN model</span></a></li><li><a class="tocitem" href="#Results"><span>Results</span></a></li><li><a class="tocitem" href="#Reproducibility"><span>Reproducibility</span></a></li></ul></li><li><a class="tocitem" href="../tuto_add_station_variable/">Multivariate SWG: Application to crop model</a></li></ul></li><li><a class="tocitem" href="../../api/">🧰 Utilities</a></li><li><a class="tocitem" href="../../other_pkg/">🌐 Other SWG Packages</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">📎 Tutorials</a></li><li class="is-active"><a href>Multisite rainfall HMM based SWG (paper) </a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multisite rainfall HMM based SWG (paper) </a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dmetivie/StochasticWeatherGenerators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dmetivie/StochasticWeatherGenerators.jl/blob/master/examples/tuto_paper.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia hljs">import Pkg;</code></pre><h1 id="TutoSHHMM"><a class="docs-heading-anchor" href="#TutoSHHMM">Multisite rainfall HMM based SWG (paper)</a><a id="TutoSHHMM-1"></a><a class="docs-heading-anchor-permalink" href="#TutoSHHMM" title="Permalink"></a></h1><p>This tutorial describes the numerical applications described in the paper <a href="https://hal.inrae.fr/hal-04621349"><em>Interpretable Seasonal Multisite Hidden Markov Model for stochastic rain generation in France</em></a> by <a href="http://www.cmap.polytechnique.fr/~gobet/">Emmanuel Gobet</a> (CMAP - École Polytechnique), <a href="https://davidmetivier.mistea.inrae.fr/">David Métivier</a> (MISTEA – INRAE) and <a href="https://fr.linkedin.com/in/sylvie-parey-60285194">Sylvie Parey</a> (R&amp;D – EDF). It shows a fully reproducible example on how to use the package <code>StochasticWeatherGenerators.jl</code> to reproduce, step-by-step, exactly (almost) all the figures of the paper.</p><p>The paper describes the construction of a Stochastic Weather Generator with an Autoregressive Seasonal Hidden Markov Model (SHMM). The SHMM is trained with French weather stations, and the hidden states are interpreted as weather regimes. The model is validated with simulations, especially for its ability to reproduce extreme weather, e.g. droughts. In the paper, the model is also used with Climate Change RCP scenarios (not shown here).</p><img src="https://github.com/dmetivie/StochasticWeatherGenerators.jl/assets/46794064/5fe1d677-877d-4fd5-83ac-29d30f728ca5" width="95%" alt = "Schematic of the Autoregressive Seasonal Hidden Markov Model"/><h2 id="Set-up"><a class="docs-heading-anchor" href="#Set-up">Set up</a><a id="Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up" title="Permalink"></a></h2><h3 id="Package-and-functions"><a class="docs-heading-anchor" href="#Package-and-functions">Package and functions</a><a id="Package-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Package-and-functions" title="Permalink"></a></h3><div class="admonition is-info" id="For-Julia-new-user-659132ef6bee4c3f"><header class="admonition-header">For Julia new user<a class="admonition-anchor" href="#For-Julia-new-user-659132ef6bee4c3f" title="Permalink"></a></header><div class="admonition-body"><p>There are several ways to <code>add</code> a package before <code>using</code>, one way is for this tutorial to copy-paste (it might take a while):</p><pre><code class="language-julia hljs">import Pkg
Pkg.add([&quot;CSV&quot;, &quot;JLD&quot;, &quot;DelimitedFiles&quot;, &quot;DataFrames&quot;, &quot;DataFramesMeta&quot;, &quot;StatsBase&quot;, &quot;Random&quot;, &quot;Distributions&quot;, &quot;StatsPlots&quot;, &quot;LaTeXStrings&quot;])</code></pre></div></div><pre><code class="language-julia hljs">using CSV, JLD, DelimitedFiles # File Read/Load/Save

using DataFrames, DataFramesMeta # DataFrames

using Dates

using StatsBase, Random

using Distributions</code></pre><p>The main package is <code>StochasticWeatherGenerators.jl</code>, which provides the interface to the models and data. <code>SmoothPeriodicStatsModels.jl</code> contains the smooth periodic models (fit and sampling methods) used in this tutorial, namely the Seasonal Hidden Markov Model (SHMM), and the seasonal mixture models for rainfall amounts.</p><pre><code class="language-julia hljs">using StochasticWeatherGenerators # interface to use with SmoothPeriodicStatsModels.jl

using SmoothPeriodicStatsModels # Name might change. Small collection of smooth periodic models e.g. AR, HMM</code></pre><pre><code class="language-julia hljs">Random.seed!(1234)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.TaskLocalRNG()</code></pre><h3 id="Settings-for-plotting"><a class="docs-heading-anchor" href="#Settings-for-plotting">Settings for plotting</a><a id="Settings-for-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Settings-for-plotting" title="Permalink"></a></h3><p>Some settings and packages to have nice plots.</p><pre><code class="language-julia hljs">using StatsPlots, LaTeXStrings
using StatsPlots.PlotMeasures # To play with margin in Plots

gr() # plotly() # for interactive plots
default(fontfamily=&quot;Computer Modern&quot;)
cur_colors = get_color_palette(:auto, 100);
my_palette(K) = palette(vcat(cur_colors[1], [cur_colors[c] for c in 3:4], cur_colors[2]), K)

file_for_plot_utilities = download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/examples/utilities_plot.jl&quot;)
include(file_for_plot_utilities)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cyclic (generic function with 1 method)</code></pre><p>To plot maps, we use <code>GeoMakie.jl</code> + <code>NaturalEarth.jl</code>. Note that using <code>cartopy</code> with <code>PyCall.jl</code> also works very well.</p><p>For the following code to work you will need to add the following packages</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(&quot;NaturalEarth&quot;, &quot;GeoMakie&quot;, &quot;CairoMakie&quot;)</code></pre><pre><code class="language-julia hljs">file_for_maps_with_geomakie = download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/examples/utilities_geo_makie_features.jl&quot;) # download file from a GitHub repo
include(file_for_maps_with_geomakie)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">savefigcrop (generic function with 4 methods)</code></pre><h3 id="Global-Parameters"><a class="docs-heading-anchor" href="#Global-Parameters">Global Parameters</a><a id="Global-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Parameters" title="Permalink"></a></h3><p>The period of the Seasonal HMM is chosen as the number of days in a year. Our choice is 366 however we carefully skip February 29 when needed.</p><pre><code class="language-julia hljs">T = 366</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">366</code></pre><p>Define the French area for map (Longitude and latitude) plot and the precision of the map <code>precision_scale</code></p><pre><code class="language-julia hljs">precision_scale = 50 # meter

LON_min = -5 # West

LON_max = 10 # East

LAT_min = 41 # South

LAT_max = 52 # North</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">52</code></pre><p><code>conversion_factor</code> for rainfall amounts <code>RR</code> in 0.1 mm to mm</p><pre><code class="language-julia hljs">conversion_factor = 0.1 # 0.1 mm -&gt; mm</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.1</code></pre><h2 id="HMM-Hyperparameters"><a class="docs-heading-anchor" href="#HMM-Hyperparameters">HMM Hyperparameters</a><a id="HMM-Hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#HMM-Hyperparameters" title="Permalink"></a></h2><p>Number of hidden states</p><pre><code class="language-julia hljs">K = 4

my_pal = my_palette(K); # just colors I like for plotting weather regime!</code></pre><p>Degree <code>𝐃𝐞𝐠</code> of the trigonometric expansion It could be an array different for each station and variable. Not implemented yet though.</p><pre><code class="language-julia hljs">𝐃𝐞𝐠 = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>Local memory order i.e. at station <span>$j$</span>, <span>$\mathbb{P}(Y_n^{(j)} = y_n^{(j)} \mid Z = k, Y_{n-1:n-\texttt{local memory}}^{(j)} = y_{n-1:n-\texttt{local memory}}^{(j)})$</span></p><pre><code class="language-julia hljs">local_order = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><div class="admonition is-info" id="Note-740280c75f202a9f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-740280c75f202a9f" title="Permalink"></a></header><div class="admonition-body"><p>The <code>local_order</code> and/or <code>𝐃𝐞𝐠</code> could be a vector/matrix of size <code>D</code> and different for each station, and also different depending on wet or dry past. Not yet implemented.</p></div></div><pre><code class="language-julia hljs">size_order = 2^local_order

println(&quot;K = $K, &quot;, &quot;degree = $𝐃𝐞𝐠, &quot;, &quot;local_order = $local_order&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">K = 4, degree = 1, local_order = 1</code></pre><h2 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h2><h3 id="Select-relevant-stations-from-the-station.txt-file"><a class="docs-heading-anchor" href="#Select-relevant-stations-from-the-station.txt-file">Select relevant stations from the <code>station.txt</code> file</a><a id="Select-relevant-stations-from-the-station.txt-file-1"></a><a class="docs-heading-anchor-permalink" href="#Select-relevant-stations-from-the-station.txt-file" title="Permalink"></a></h3><p>Here we</p><ul><li>Remove white space at the right of the <code>CN</code>, STANAME which is caused by imperfect CVS importation</li><li>Select only the stations with 100% valid data for the period <code>Date(1955,12,31) .≤ :DATE .≤ Date(2019,12,31)</code></li><li>Shorten station names</li></ul><pre><code class="language-julia hljs">begin
    station_file = Base.download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/weather_files/stations.txt&quot;)
    station_all = CSV.read(station_file, DataFrame, header=18, normalizenames=true, ignoreemptyrows=true)
    station_all = @chain station_all begin
        @transform(:CN = rstrip.(:CN), :STANAME = rstrip.(:STANAME))
        # @subset(:CN .∈ tuple([&quot;FR&quot;, &quot;BE&quot;, &quot;LU&quot;, &quot;CH&quot;])) # Choose that if you want to look at all stations in France, Belgium, Luxembourg and Switzerland.
        @subset(:STAID .∈ tuple([32, 33, 34, 36, 39, 203, 322, 323, 434, 736, 737, 738, 740, 742, 745, 749, 750, 755, 756, 757, 758, 786, 793, 2192, 2203, 2205, 2207, 2209, 11244, 11245, 11247, 11249]))
        @transform(:STANAME = shortname.(:STANAME))
    end
end

selected_station_name = [&quot;BOURGES&quot;, &quot;TOULOUSE&quot;, &quot;MARIGNANE&quot;, &quot;LUXEMBOURG&quot;, &quot;LILLE&quot;, &quot;EMBRUN&quot;, &quot;BASTIA&quot;, &quot;LA HAGUE&quot;, &quot;CHASSIRON&quot;, &quot;ORLY&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{String}:
 &quot;BOURGES&quot;
 &quot;TOULOUSE&quot;
 &quot;MARIGNANE&quot;
 &quot;LUXEMBOURG&quot;
 &quot;LILLE&quot;
 &quot;EMBRUN&quot;
 &quot;BASTIA&quot;
 &quot;LA HAGUE&quot;
 &quot;CHASSIRON&quot;
 &quot;ORLY&quot;</code></pre><div class="admonition is-info" id="Hypothesis:-Conditional-Independence-of-Rain-Occurrences-3a5840e8ae263fb3"><header class="admonition-header">Hypothesis: Conditional Independence of Rain Occurrences<a class="admonition-anchor" href="#Hypothesis:-Conditional-Independence-of-Rain-Occurrences-3a5840e8ae263fb3" title="Permalink"></a></header><div class="admonition-body"><p>You can change the selected stations. However, keep in mind that for the model to work, the <strong>conditional independence hypothesis</strong> must hold between stations i.e. <span>$\mathbb{P}(Y_1 = y_1, \cdots, Y_S = y_s\mid Z = k) = \prod_{s=1}^S \mathbb{P}(Y_s = y_s)$</span>. Hence stations must be sufficiently far apart. Check out this <a href="https://dmetivie.github.io/ExpectationMaximization.jl/dev/examples/#MNIST-dataset:-Bernoulli-Mixture">MNIST example</a> to see Bernoulli mixtures in action!</p></div></div><pre><code class="language-julia hljs">station = @subset(station_all, :STANAME .∈ tuple(selected_station_name))

STAID = station.STAID #[32, 33, 39, 203, 737, 755, 758, 793, 11244, 11249];

station_name = station.STANAME</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{SubString{String}}:
 &quot;BOURGES&quot;
 &quot;TOULOUSE&quot;
 &quot;MARIGNANE&quot;
 &quot;LUXEMBOURG&quot;
 &quot;LILLE&quot;
 &quot;EMBRUN&quot;
 &quot;BASTIA&quot;
 &quot;LA HAGUE&quot;
 &quot;CHASSIRON&quot;
 &quot;ORLY&quot;</code></pre><p>Sort stations (index) by latitude. It is useful for plotting from North to South.</p><pre><code class="language-julia hljs">staid_lat = sortperm(station.LAT, rev=true);</code></pre><p>Station number</p><pre><code class="language-julia hljs">D = length(STAID)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10</code></pre><h3 id="Date-range"><a class="docs-heading-anchor" href="#Date-range">Date range</a><a id="Date-range-1"></a><a class="docs-heading-anchor-permalink" href="#Date-range" title="Permalink"></a></h3><pre><code class="language-julia hljs">date_start = Date(1956)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1956-01-01</code></pre><p>Date including the previous days used in the initial condition (in case <code>local_memory &gt; 0</code>)</p><pre><code class="language-julia hljs">date_start_w_memory = date_start - Day(local_order)

date_end = Date(2020) - Day(1)

every_year = date_start:Day(1):date_end

every_year_w_memory = date_start_w_memory:Day(1):date_end

n2t = dayofyear_Leap.(every_year)

N = length(n2t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">23376</code></pre><h3 id="Treat-data"><a class="docs-heading-anchor" href="#Treat-data">Treat data</a><a id="Treat-data-1"></a><a class="docs-heading-anchor-permalink" href="#Treat-data" title="Permalink"></a></h3><p>Load into a <code>DataFrame</code> the (ECA) RR files (rain). It filters by date and valid data. It also adds a column <code>:RO</code> for rain occurrences (0: dry, 1: wet).</p><pre><code class="language-julia hljs">begin
    data_stations = collect_data_ECA.(STAID, date_start_w_memory, date_end, &quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/weather_files/ECA_blend_rr/RR_&quot;, portion_valid_data=1, skipto=22, header=21, url=true)
    for i = eachindex(data_stations)
        @transform!(data_stations[i], :RO = onefy.(:RR))
    end
end</code></pre><p>Binary matrix version of the rain event at the <code>D</code> stations.</p><pre><code class="language-julia hljs">RR = reduce(hcat, [data_stations[j].RR[1+local_order:end] for j = 1:D]) * 0.1

Yall = BitMatrix(reduce(hcat, [data_stations[j].RO for j = 1:D]))

Y_past = BitMatrix(Yall[1:local_order, :]) # rand(Bool, local_order, D)

ξ = [1; zeros(K - 1)];  # 1 jan 1956 was most likely a type Z = 1 wet day all over France

Y = Yall[1+local_order:end, :]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">23376×10 BitMatrix:
 1  1  1  1  1  1  1  1  1  1
 1  1  0  1  1  0  1  0  1  0
 0  0  0  0  0  0  1  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  1  1  0  0  0  0  0  0  1
 1  1  1  0  1  0  1  1  1  1
 1  1  1  1  1  1  0  0  1  1
 0  1  1  1  1  1  1  1  1  0
 1  0  0  1  1  1  0  1  1  1
 ⋮              ⋮           
 1  1  0  1  1  1  0  1  1  1
 1  0  0  1  1  0  0  0  0  0
 0  0  0  1  0  0  0  1  1  0
 1  0  0  1  1  0  0  1  0  1
 1  0  0  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  1  0
 0  0  0  0  1  0  0  0  1  0
 0  0  0  0  0  0  0  0  1  0
 0  0  0  0  0  0  0  0  1  0</code></pre><h3 id="Map-of-stations"><a class="docs-heading-anchor" href="#Map-of-stations">Map of stations</a><a id="Map-of-stations-1"></a><a class="docs-heading-anchor-permalink" href="#Map-of-stations" title="Permalink"></a></h3><p>Convert LAT/LON coordinates from DMS to DD which seems most widely accepted format.</p><pre><code class="language-julia hljs">LAT_idx = dms_to_dd.(station.LAT)

LON_idx = dms_to_dd.(station.LON)

long_spell = [longuest_spell(y) for y in eachcol(Y)]

FR_map_spell = map_with_stations(LON_idx, LAT_idx, long_spell; station_name=station_name, show_value=true, colorbar_show=true, precision_scale = precision_scale, colorbar_label = &quot;Days&quot;)</code></pre><img src="4c22722e.png" alt="Example block output"/><h2 id="Fit-the-seasonal-HMM"><a class="docs-heading-anchor" href="#Fit-the-seasonal-HMM">Fit the seasonal HMM</a><a id="Fit-the-seasonal-HMM-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-the-seasonal-HMM" title="Permalink"></a></h2><div class="admonition is-info" id="Hypothesis:-Smooth-parameter-evolution-2e46c34d4ec2476"><header class="admonition-header">Hypothesis: Smooth parameter evolution<a class="admonition-anchor" href="#Hypothesis:-Smooth-parameter-evolution-2e46c34d4ec2476" title="Permalink"></a></header><div class="admonition-body"><p>We assume all models e.g. HMM, rain mixture to have parameters evolving smoothly with periodicity <span>$T$</span> for <span>$t \in [1, T]$</span>. For example a Bernoulli parameter will write</p><p class="math-container">\[p(t) = \dfrac{1}{1 + e^{P(t)}} \in [0, 1],\]</p><p>with</p><p class="math-container">\[    P_c(t) = c_0 + \sum_{j=1}^{\texttt{Deg}} \left(c_{2j-1}\cos\left(\dfrac{2\pi}{T}j t\right) + c_{2j}\sin\left(\dfrac{2\pi}{T}j t\right)\right).\]</p></div></div><h3 id="Fit-slice:-naive-estimation"><a class="docs-heading-anchor" href="#Fit-slice:-naive-estimation">Fit slice: naive estimation</a><a id="Fit-slice:-naive-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-slice:-naive-estimation" title="Permalink"></a></h3><div class="admonition is-info" id="Note-75ce3399ffe4b8c9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-75ce3399ffe4b8c9" title="Permalink"></a></header><div class="admonition-body"><p>Before inferring the HMM parameters with the EM (Baum-Welch) algorithm, we do a first naive inference that will be used as initial condition for the EM.</p></div></div><p>The reference station <code>ref_station</code> is used to sort the hidden states obtained via the slide initialization Here we choose <code>j=1</code> <span>$\to$</span> <code>STAID=32</code> <span>$\to$</span> <code>BOURGES</code> because it is a central station for France</p><pre><code class="language-julia hljs">ref_station = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>This generates a random Periodic HMM that we then fit slice by slice (day by day). See paper.</p><pre><code class="language-julia hljs">hmm_random = randARPeriodicHMM(K, T, D, local_order; ξ=ξ, ref_station=ref_station);

@time &quot;FitMLE SHMM (Slice)&quot; hmm_slice = fit_mle_all_slices(hmm_random, Y, Y_past; n2t=n2t, robust=true, rand_ini=true, Dirichlet_α=0.8, history=false, n_random_ini=1, Yₜ_extanted=[-12, -7, 0, 6, 13]);

θᴬ_slice, θᴮ_slice = fit_θ!(hmm_slice, 𝐃𝐞𝐠);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FitMLE SHMM (Slice): 27.155503 seconds (344.19 M allocations: 29.838 GiB, 14.34% gc time, 15.86% compilation time)</code></pre><h3 id="Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point"><a class="docs-heading-anchor" href="#Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point">Fit with Baum Welch using the slice estimate as a starting point</a><a id="Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point" title="Permalink"></a></h3><p>With the Slice estimate as a good starting point for the full (seasonal) Baum Welch EM algorithm we fit the model!</p><div class="admonition is-success" id="Tip-fb54351939083195"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-fb54351939083195" title="Permalink"></a></header><div class="admonition-body"><p>To accelerate the fitting procedure (especially for larger models or when testing various model hyperparameters), one can do</p><pre><code class="language-julia hljs">using Distributed
addprocs(10) # number of worker to add
@everywhere using SmoothPeriodicStatsModels # load the pkg on each worker</code></pre><p>Then the fitting loop inside <code>fit_mle</code> will be distributed. See the <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#man-distributed">official Julia doc</a> for more info. On smaller models it does not worth it since adding workers add some compilation and communication time.</p></div></div><pre><code class="language-julia hljs">@time &quot;FitMLE SHMM (Baum Welch)&quot; hmm_fit, θq_fit, θy_fit, hist, histo_A, histo_B = fit_mle(hmm_slice, θᴬ_slice, θᴮ_slice, Y, Y_past, maxiter=10000, robust=true; display=:iter, silence=true, tol=1e-3, θ_iters=true, n2t=n2t);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iteration 0: logtot = -122032.50888854622
Iteration 1: logtot = -119978.989709, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.5859 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.75979
Iteration 2: logtot = -118851.217736, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.32943 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.65147
Iteration 3: logtot = -117984.404189, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.27123 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.76473
Iteration 4: logtot = -117530.910729, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.23744 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.68865
Iteration 5: logtot = -117334.429045, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.1803 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.49175
Iteration 6: logtot = -117243.473606, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.12904 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.31446
Iteration 7: logtot = -117196.530696, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.11048 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.19502
Iteration 8: logtot = -117170.63798, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.09375 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.11894
Iteration 9: logtot = -117155.713125, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.07686 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.07913
Iteration 10: logtot = -117146.773266, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.06192 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.05726
Iteration 11: logtot = -117141.209453, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.04946 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.04106
Iteration 12: logtot = -117137.610304, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.03938 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.02995
Iteration 13: logtot = -117135.19217, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.03137 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.02801
Iteration 14: logtot = -117133.508369, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.02507 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.02579
Iteration 15: logtot = -117132.297044, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.02012 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.02346
Iteration 16: logtot = -117131.400073, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.01624 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.02115
Iteration 17: logtot = -117130.719034, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.0132 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.01895
Iteration 18: logtot = -117130.190784, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.01147 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.01691
Iteration 19: logtot = -117129.773603, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.01014 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.01505
Iteration 20: logtot = -117129.439134, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00893 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.01338
Iteration 21: logtot = -117129.167591, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00784 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.01191
Iteration 22: logtot = -117128.944818, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00687 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.01061
Iteration 23: logtot = -117128.760462, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00602 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00948
Iteration 24: logtot = -117128.606792, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00527 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00849
Iteration 25: logtot = -117128.477925, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00461 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00763
Iteration 26: logtot = -117128.369315, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00404 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00688
Iteration 27: logtot = -117128.277391, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00355 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00623
Iteration 28: logtot = -117128.199315, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00312 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00565
Iteration 29: logtot = -117128.132804, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00275 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00515
Iteration 30: logtot = -117128.076002, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00243 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.0047
Iteration 31: logtot = -117128.027389, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00216 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00431
Iteration 32: logtot = -117127.985708, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.002 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00396
Iteration 33: logtot = -117127.949915, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00185 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00364
Iteration 34: logtot = -117127.919136, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00172 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00336
Iteration 35: logtot = -117127.89264, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.0016 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.0031
Iteration 36: logtot = -117127.869805, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00148 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00287
Iteration 37: logtot = -117127.85011, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00138 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00265
Iteration 38: logtot = -117127.833108, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00128 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00246
Iteration 39: logtot = -117127.81842, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00119 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00228
Iteration 40: logtot = -117127.805725, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00111 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00212
Iteration 41: logtot = -117127.794745, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00103 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00196
Iteration 42: logtot = -117127.785244, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00096 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00183
Iteration 43: logtot = -117127.777018, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.0009 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.0017
Iteration 44: logtot = -117127.769893, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00084 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00158
Iteration 45: logtot = -117127.76372, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00078 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00147
Iteration 46: logtot = -117127.758369, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00073 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00136
Iteration 47: logtot = -117127.753729, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00068 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00127
Iteration 48: logtot = -117127.749705, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00063 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00118
Iteration 49: logtot = -117127.746213, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00059 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.0011
Iteration 50: logtot = -117127.743182, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00055 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00102
Iteration 51: logtot = -117127.740551, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00051 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00095
Iteration 52: logtot = -117127.738266, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00048 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00088
Iteration 53: logtot = -117127.736282, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00044 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00082
Iteration 54: logtot = -117127.734558, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00041 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00076
Iteration 55: logtot = -117127.733059, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00039 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00071
Iteration 56: logtot = -117127.731757, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00036 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00066
Iteration 57: logtot = -117127.730625, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00034 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00061
Iteration 58: logtot = -117127.72964, max(|θᴬᵢ-θᴬᵢ₋₁|) = 0.00031 &amp; max(|θᴮᵢ-θᴮᵢ₋₁|) = 0.00057
EM converged in 58 iterations, logtot = -117127.72964034643
FitMLE SHMM (Baum Welch): 32.712062 seconds (162.52 M allocations: 16.583 GiB, 4.91% gc time, 12.53% compilation time)</code></pre><p>Run the following code to load a saved hmm</p><pre><code class="language-julia hljs">hmm_infos = load(joinpath(save_tuto_path,&quot;hmm_fit_K_$(K)_d_$(𝐃𝐞𝐠)_m_$(local_order).jld&quot;))
hmm_fit = hmm_infos[&quot;hmm&quot;]
hist = hmm_infos[&quot;hist&quot;]
θq_fit = hmm_infos[&quot;Q_param&quot;]
θy_fit = hmm_infos[&quot;Y_param&quot;]</code></pre><h3 id="Visualization-of-the-HMM-parameters"><a class="docs-heading-anchor" href="#Visualization-of-the-HMM-parameters">Visualization of the HMM parameters</a><a id="Visualization-of-the-HMM-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-the-HMM-parameters" title="Permalink"></a></h3><h4 id="Transition-matrix"><a class="docs-heading-anchor" href="#Transition-matrix">Transition matrix</a><a id="Transition-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-matrix" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    pA = [plot(legendfont=14, foreground_color_legend=nothing, background_color_legend=nothing, legend_columns=4, tickfont=12, legendfontsize=16) for k in 1:K]
    for k in 1:K
        [plot!(pA[k], hmm_fit.A[k, l, :], c=my_color(l, K), label=L&quot;Q_{%$(k)\to %$(l)}&quot;, legend=:top, lw=1.75) for l in 1:K]
        hline!(pA[k], [0.5], c=:black, label=:none, s=:dot)
        xticks!(pA[k], vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366), vcat(string.(monthabbr.(1:12)), &quot;&quot;), xlims=(0, 367), ylims=(0, 1))
    end
    pallA = plot(pA..., size=(1000, 500))
end</code></pre><img src="3a8b0829.svg" alt="Example block output"/><h4 id="Rain-probabilities"><a class="docs-heading-anchor" href="#Rain-probabilities">Rain probabilities</a><a id="Rain-probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-probabilities" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    mm = 1
    jt = D
    pB = [plot(legendfont=14, title=&quot;$(station_name[j])&quot;, titlefontsize=17, tickfont=14, legendfontsize = 16) for j in 1:jt]
    for j in 1:jt
        [plot!(pB[j], succprob.(hmm_fit.B[k, :, j, mm]), c=my_color(k, K), label=islabel(j, 3, L&quot;\mathbb{P}(Y = \textrm{wet}\mid Z = %$k, H = \textrm{dry})&quot;), lw=2) for k in 1:K]
        hline!(pB[j], [0.5], c=:black, label=:none, s=:dot)
        xticks!(
            pB[j],
            vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366),
            vcat(string.(first.(monthabbr.(1:12))))
        )
        xlims!(pB[j], (0, 367))
        ylims!(pB[j], (0, 1))
    end
    pallB = plot(pB[staid_lat]..., size=(3000 / 2, 1000 / 1), layout=(2, 5))
end</code></pre><img src="47e366e5.svg" alt="Example block output"/><h4 id="Spatial-Rain-probability"><a class="docs-heading-anchor" href="#Spatial-Rain-probability">Spatial Rain probability</a><a id="Spatial-Rain-probability-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-Rain-probability" title="Permalink"></a></h4><pre><code class="language-julia hljs">memory_past_cat = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>h = 1 (day before dry) or 2 (day before wet) <span>$\mathbb{P}(Y = \text{Rain}\mid Z = k, H = h)$</span> with <code>h = memory_past_cat</code></p><p>For now there are some scale rendering issues due to an <a href="https://github.com/MakieOrg/GeoMakie.jl/issues/268">GeoMakie.jl issue</a> so it might be tiny.</p><pre><code class="language-julia hljs">p_FR_map_mean_prob = map_with_stations(LON_idx, LAT_idx, [[mean(succprob.(hmm_fit.B[k, :, j, memory_past_cat])) for j in 1:length(STAID)] for k in 1:K], colorbar_show=true, colorbar_label = L&quot;\mathbb{P}(Y = \text{Rain}\mid Z = k, H = 1)&quot;, precision_scale = precision_scale)</code></pre><img src="5e538f60.png" alt="Example block output"/><h3 id="Inference-of-the-historical-hidden-states"><a class="docs-heading-anchor" href="#Inference-of-the-historical-hidden-states">Inference of the historical hidden states</a><a id="Inference-of-the-historical-hidden-states-1"></a><a class="docs-heading-anchor-permalink" href="#Inference-of-the-historical-hidden-states" title="Permalink"></a></h3><h4 id="Viterbi-algorithm"><a class="docs-heading-anchor" href="#Viterbi-algorithm">Viterbi algorithm</a><a id="Viterbi-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Viterbi-algorithm" title="Permalink"></a></h4><pre><code class="language-julia hljs">ẑ = viterbi(hmm_fit, Y, Y_past; n2t=n2t)

data_stations_z = map(data_stations) do df
    @transform(df, :z = [fill(missing, local_order); ẑ])
end

ẑ_per_cat = [findall(ẑ .== k) for k in 1:K]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Int64}}:
 [1, 7, 8, 12, 17, 23, 29, 44, 80, 81  …  23356, 23357, 23358, 23359, 23362, 23364, 23365, 23366, 23367, 23368]
 [2, 10, 11, 14, 18, 20, 21, 22, 25, 26  …  23328, 23333, 23351, 23352, 23355, 23360, 23361, 23369, 23370, 23371]
 [6, 9, 13, 15, 16, 24, 27, 30, 31, 40  …  23325, 23330, 23331, 23334, 23335, 23339, 23345, 23346, 23350, 23363]
 [3, 4, 5, 19, 32, 33, 34, 38, 46, 48  …  23295, 23332, 23347, 23348, 23349, 23372, 23373, 23374, 23375, 23376]</code></pre><h4 id="Visualization-of-the-historical-sequences-of-hidden-states"><a class="docs-heading-anchor" href="#Visualization-of-the-historical-sequences-of-hidden-states">Visualization of the historical sequences of hidden states</a><a id="Visualization-of-the-historical-sequences-of-hidden-states-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-the-historical-sequences-of-hidden-states" title="Permalink"></a></h4><pre><code class="language-julia hljs">year_range = unique(year.(data_stations[1][1+local_order:end, :DATE]));

idx_year = [findall(x -&gt; year.(x) == m, data_stations[1][1+local_order:end, :DATE]) for m in year_range];

select_year = unique(sort([4:10:length(year_range); 21; 48; 64]))

begin
    year_nb = length(select_year)
    z_hat_mat = zeros(year_nb, 366)

    for (i, y) in enumerate(select_year)
        if isleapyear(year_range[y])
            z_hat_mat[i, :] = ẑ[idx_year[y]]
        else
            z_hat_mat[i, :] = [ẑ[idx_year[y]]; 0]
        end
    end
    thick = 1
    heatmap(z_hat_mat, colorbar=:none, c=my_palette(K), minorticks=:false, framestyle=:xbox, grid=:none, thickness_scaling=thick)
    xticks!(vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366), vcat(string.(monthabbr.(1:12)), &quot;&quot;), xlims=(0, 367), xtickfontsize=14 / thick, ytickfontsize=14 / thick)
    hline!((1:year_nb) .+ 0.5, c=:black, legend=:none, lw=4)
    ylims!(0.5, year_nb + 0.5)
    pviterbi = yticks!(1:year_nb, string.(year_range[select_year]), size=(1000, 600))
end</code></pre><img src="eeb355c3.svg" alt="Example block output"/><h2 id="Adding-Rainfall-amounts-to-the-model"><a class="docs-heading-anchor" href="#Adding-Rainfall-amounts-to-the-model">Adding Rainfall amounts to the model</a><a id="Adding-Rainfall-amounts-to-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Rainfall-amounts-to-the-model" title="Permalink"></a></h2><h3 id="Marginal-distribution"><a class="docs-heading-anchor" href="#Marginal-distribution">Marginal distribution</a><a id="Marginal-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Marginal-distribution" title="Permalink"></a></h3><p>We fit the marginals of the rainfall amount <span>$R&gt;0$</span> at each station <span>$s$</span> and for each hidden state <span>$Z$</span> independently. We use a mixture of exponential functions</p><p class="math-container">\[g(r) = w \dfrac{e^{-{\frac {r}{\vartheta_1}}}}{\vartheta_1} + (1-w)  \dfrac{e^{-{\frac {r}{\vartheta_2}}}}{\vartheta_2}.\]</p><p>whose parameters <span>$w(t)$</span>, <span>$\vartheta_1(t)$</span> and <span>$\vartheta_2(t)$</span> are smooth periodic functions of the day of the year.</p><pre><code class="language-julia hljs">@time &quot;FitMLE RR&quot; mix_allE = fit_mle_RR.(data_stations_z, local_order, mix₀=mix_ini(T));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FitMLE RR: 70.572252 seconds (330.73 M allocations: 30.791 GiB, 3.77% gc time, 1.45% compilation time)</code></pre><p>Thanks to <a href="https://github.com/JuliaStats/Distributions.jl/pull/1389">Distributions.jl PR #1389 (September 2nd, 2021)</a> and Julia multiple dispatch, the quantile function of Mixtures can be very efficiently computed.</p><h3 id="Rain-correlations"><a class="docs-heading-anchor" href="#Rain-correlations">Rain correlations</a><a id="Rain-correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-correlations" title="Permalink"></a></h3><p>We fit a Gaussian copula to each pair of stations for joint rainy days only.</p><div class="admonition is-warning" id="Warning-15442267d90604fd"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-15442267d90604fd" title="Permalink"></a></header><div class="admonition-body"><p>For some hidden states corresponding to dry weather, it might happen that for some pair of stations, there are not enough simultaneous rain occurrences in a rain category <span>$Z = k$</span> to estimate a correlation coefficient. In that case a <code>missing</code> coefficient is returned by <code>cov_RR</code> or it returns the value <code>impute_missing</code> if specified (to avoid missing). The option <code>force_PosDef</code> (enabled by default) ensures having positive definite matrix. This is necessary to use gaussian copula.</p></div></div><pre><code class="language-julia hljs">Σ²RR = cov_RR(data_stations_z, K)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Matrix{Float64}}:
 [3879.3410237455955 643.1969973888454 … 1044.722558290334 1422.1412369837526; 643.1969973888454 3906.8065809319683 … 421.21726685970293 261.80966034462176; … ; 1044.722558290334 421.21726685970293 … 3782.5212727685685 797.3469589896836; 1422.1412369837526 261.80966034462176 … 797.3469589896836 3100.798265766617]
 [2301.9313610952054 485.18478831568194 … 770.578089634074 863.0300234394578; 485.18478831568194 2006.8630718718769 … 428.13538892508905 271.67257203655475; … ; 770.578089634074 428.13538892508905 … 2440.5330122895875 592.8827865026185; 863.0300234394578 271.67257203655475 … 592.8827865026185 1893.078927735636]
 [2948.5928743209097 750.2824568975376 … 621.8223025654515 827.3791552074431; 750.2824568975376 5838.066822339216 … 369.18199793741627 352.11239948672414; … ; 621.8223025654515 369.18199793741627 … 2871.8548379173185 652.5033493795553; 827.3791552074431 352.11239948672414 … 652.5033493795553 2070.968133316776]
 [2578.6677735877342 939.3858870148969 … 533.7956218371148 -108.18202437342076; 939.3858870148969 3052.544041679537 … 895.8296379061048 212.7174426012282; … ; 533.7956218371148 895.8296379061048 … 1706.7038943029056 -415.34586196345674; -108.18202437342076 212.7174426012282 … -415.34586196345674 803.7842493374762]</code></pre><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><p>Now we are ready to generate samples from the SWG model.</p><p><code>Nb</code> is the number of realization. In (<a href="../../models/rain/#cit-2024_gobet_InterpretableSeasonalHiddena">Gobet <em>et al.</em>, Sep 2024</a>) <code>Nb = 5_000</code> was used.</p><pre><code class="language-julia hljs">Nb = 1_000</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000</code></pre><p>Sample the (seasonal) HMM model and output the sequence of hidden states and multi-site dry/wet.</p><pre><code class="language-julia hljs">begin
    zs = zeros(Int, N, Nb)
    ys = zeros(Bool, N, D, Nb)
    @time &quot;Simulations Z, Y&quot; for i in 1:Nb
        zs[:, i], ys[:, :, i] = rand(hmm_fit, n2t; y_ini=Yall[1:local_order, :], z_ini=1, seq=true)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulations Z, Y: 19.052084 seconds (374.84 M allocations: 23.093 GiB, 18.33% gc time, 7.01% compilation time)</code></pre><p>Given the hidden states and dry/wet, it generates the rainfall amounts at each station (correlated with a Gaussian Copula).</p><pre><code class="language-julia hljs">begin
    rs = zeros(D, N, Nb)
    @time &quot;Simulations RR&gt;0&quot; for i in 1:Nb
        rs[:, :, i] = rand_RR(mix_allE, n2t, zs[:, i], ys[:, :, i]&#39;, Σ²RR)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulations RR&gt;0: 234.527307 seconds (412.87 M allocations: 33.651 GiB, 1.89% gc time, 0.23% compilation time)</code></pre><h2 id="TutoWGEN"><a class="docs-heading-anchor" href="#TutoWGEN">WGEN model</a><a id="TutoWGEN-1"></a><a class="docs-heading-anchor-permalink" href="#TutoWGEN" title="Permalink"></a></h2><p>We will compare to the WGEN model that propose Markov chain of order 4 for rain occurrences (fitted monthly) and laten gaussian model for multisite occurrences (fitted monthly).</p><ul><li>Wilks, D. S. &quot;Multisite generalization of a daily stochastic precipitation generation model&quot;. Journal of Hydrology, (1998). https://doi.org/10.1016/S0022-1694(98)00186-3.</li><li>Srikanthan, Ratnasingham, et Geoffrey G. S. Pegram. &quot;A nested multisite daily rainfall stochastic generation model&quot;. Journal of Hydrology 2009. https://doi.org/10.1016/j.jhydrol.2009.03.025.</li></ul><pre><code class="language-julia hljs">wgen_order = 4
idx_months = [findall(x -&gt; month.(x) == m, data_stations[1][1+local_order:end, :DATE]) for m in 1:12]
wgen4_model = fit_wgen(Y, idx_months, wgen_order)

ys_wgen = similar(ys)
@time &quot;Simulation Y wgen 4&quot; for i in 1:Nb
    ys_wgen[:, :, i] = rand(wgen4_model, 1956:2019; Y_ini=vcat(rand(Bool, wgen_order - 1, D), Y_past))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation Y wgen 4: 74.644881 seconds (1.90 G allocations: 66.297 GiB, 11.56% gc time, 1.40% compilation time)</code></pre><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><h3 id="Spell-distribution"><a class="docs-heading-anchor" href="#Spell-distribution">Spell distribution</a><a id="Spell-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Spell-distribution" title="Permalink"></a></h3><p><code>select_month</code> to choose the month where to compute the spell distributions (summer month, winter, etc.) <code>select_month = 1:12</code> corresponds to all months.</p><pre><code class="language-julia hljs">select_month = 1:12

idx_months = [findall(x -&gt; month.(x) == m, data_stations[1][1+local_order:end, :DATE]) for m in 1:12]

idx_month_vcat = vcat(idx_months[select_month]...)

idx_all = [intersect(yea, mon) for yea in idx_year, mon in idx_months];</code></pre><h5 id="Historic-spells"><a class="docs-heading-anchor" href="#Historic-spells">Historic spells</a><a id="Historic-spells-1"></a><a class="docs-heading-anchor-permalink" href="#Historic-spells" title="Permalink"></a></h5><pre><code class="language-julia hljs">len_spell_hist = [pmf_spell(Y[idx_month_vcat, j], dw) for j in 1:D, dw in 0:1];</code></pre><h5 id="Simulation-spells"><a class="docs-heading-anchor" href="#Simulation-spells">Simulation spells</a><a id="Simulation-spells-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-spells" title="Permalink"></a></h5><pre><code class="language-julia hljs">len_spell_simu = [pmf_spell(ys[idx_month_vcat, j, i], dw) for i in 1:Nb, j in 1:D, dw in 0:1];</code></pre><h4 id="Dry-spell"><a class="docs-heading-anchor" href="#Dry-spell">Dry spell</a><a id="Dry-spell-1"></a><a class="docs-heading-anchor-permalink" href="#Dry-spell" title="Permalink"></a></h4><pre><code class="language-julia hljs">make_range(y, step=1) = range(extrema(y)..., step=step)

begin
    dry_or_wet = 1 # dry
    p_spell_dry = [plot(ylims=(1e-4, 1e-0), tickfont=11, legendfontsize=13) for j = 1:D]
    for j = 1:D
        all_spells = len_spell_simu[:, j, dry_or_wet]
        spell_range = 1:1:(1+maximum(vcat(reduce(vcat, all_spells), len_spell_hist[j, dry_or_wet])))

        errorlinehist!(p_spell_dry[j], all_spells, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:probability, bins=spell_range, errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median)

        errorlinehist!(p_spell_dry[j], all_spells, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median)

        histo_spell = len_spell_hist[j, dry_or_wet]
        errorlinehist!(p_spell_dry[j], [histo_spell], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:probability, bins=spell_range, errortype=:percentile, alpha = 0.8)
        xlims!(p_spell_dry[j], 0, 2 + maximum(1.5maximum.(histo_spell)))
        yaxis!(:log10)
    end

    [xlabel!(p_spell_dry[j], &quot;Nb of days&quot;, xlabelfontsize=12) for j in staid_lat[6:10]]
    [ylabel!(p_spell_dry[j], &quot;PMF&quot;, ylabelfontsize=12) for j in staid_lat[[1, 6]]]
    [title!(p_spell_dry[j], station_name[j], titlefontsize=13) for j = 1:D]
    pall_spell_dry = plot(p_spell_dry[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), left_margin=0.5cm, bottom_margin=0.275cm)
end</code></pre><img src="dedd82ad.svg" alt="Example block output"/><h4 id="Wet-spell"><a class="docs-heading-anchor" href="#Wet-spell">Wet spell</a><a id="Wet-spell-1"></a><a class="docs-heading-anchor-permalink" href="#Wet-spell" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    dry_or_wet = 2 # wet
    p_spell_wet = [plot(ylims=(1e-4, 1e-0), tickfont=11, legendfontsize=13) for j = 1:D]
    for j = 1:D
        all_spells = len_spell_simu[:, j, dry_or_wet]
        spell_range = 1:1:(1+maximum(vcat(reduce(vcat, all_spells), len_spell_hist[j, dry_or_wet])))

        errorlinehist!(p_spell_wet[j], all_spells, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:probability, bins=spell_range, errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median)

        errorlinehist!(p_spell_wet[j], all_spells, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:probability, bins=spell_range, errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median)

        histo_spell = len_spell_hist[j, dry_or_wet]
        errorlinehist!(p_spell_wet[j], [histo_spell], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:probability, bins=spell_range, errortype=:percentile, alpha = 0.8)
        xlims!(p_spell_wet[j], 0, 2 + maximum(1.5maximum.(histo_spell)))
        yaxis!(:log10)
    end

    [xlabel!(p_spell_wet[j], &quot;Nb of days&quot;, xlabelfontsize=12) for j in staid_lat[6:10]]
    [ylabel!(p_spell_wet[j], &quot;PMF&quot;, ylabelfontsize=12) for j in staid_lat[[1, 6]]]
    [title!(p_spell_wet[j], station_name[j], titlefontsize=13) for j = 1:D]
    pall_spell_wet = plot(p_spell_wet[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), left_margin=0.5cm, bottom_margin=0.275cm)
end</code></pre><img src="00d1bcf5.svg" alt="Example block output"/><h3 id="Seasonal-areal-dry-spells"><a class="docs-heading-anchor" href="#Seasonal-areal-dry-spells">Seasonal areal dry spells</a><a id="Seasonal-areal-dry-spells-1"></a><a class="docs-heading-anchor-permalink" href="#Seasonal-areal-dry-spells" title="Permalink"></a></h3><pre><code class="language-julia hljs">RRmax = 0
ROR = [mean(r .&gt; RRmax) for r in eachrow(RR)]
RORs = [[mean(r .&gt; RRmax) for r in eachrow(rr)] for rr in eachslice(ys, dims=3)]
RORswgen = [[mean(r .&gt; RRmax) for r in eachrow(rr)] for rr in eachslice(ys_wgen, dims=3)]

JJA = [6, 7, 8]
MAM = [3, 4, 5]
SON = [9, 10, 11]
DJF = [12, 1, 2]
SEASONS = [DJF, MAM, JJA, SON]
seasonname = [&quot;DJF&quot;, &quot;MAM&quot;, &quot;JJA&quot;, &quot;SON&quot;]

idx_seasons = [findall(month.(data_stations[1][1+local_order:end, :DATE]) .∈ tuple(season)) for season in SEASONS]

let
    perc = 0.2
    QQ = [5, 95]

    p_spell_rors = [plot(ylims=(5e-4, 1e-0), xlims=(-0.01,25), tickfont=11, legendfontsize=13, legend=:left) for i in eachindex(idx_seasons)]
    xlabel!.(p_spell_rors[3:end], &quot;Nb of days&quot;, xlabelfontsize=12)
    ylabel!.(p_spell_rors[[1, 3]], &quot;PMF&quot;, ylabelfontsize=12)
    for m in eachindex(idx_seasons)
        len_ror_hist = pmf_spell(ROR[idx_seasons[m]] .≤ perc, 1)
        len_ror_simu = [pmf_spell(RORs[i][idx_seasons[m]] .≤ perc, 1) for i in 1:Nb]
        len_ror_simuwgen = [pmf_spell(RORswgen[i][idx_seasons[m]] .≤ perc, 1) for i in 1:Nb]

        errorlinehist!(p_spell_rors[m], [len_ror_hist], groupcolor=:blue, lw=2, norm=:probability, bins=make_range(len_ror_hist), errortype=:percentile,
        label=label = islabel(m, 1, &quot;Obs&quot;),
        legend=:bottom)
        yaxis!(:log10)

        sim_range = make_range(reduce(vcat, len_ror_simuwgen))
        errorlinehist!(p_spell_rors[m], len_ror_simuwgen, groupcolor=:green, legend=:topright,
            label=islabel(m, 1, &quot;WGEN 4&quot;),
            norm=:probability, bins=sim_range, errortype=:percentile, percentiles=QQ, fillalpha=0.25, centertype=:median, linewidth=2)

        sim_range = make_range(reduce(vcat, len_ror_simu))
        errorlinehist!(p_spell_rors[m], len_ror_simu, groupcolor=:grey, legend=:topright,
            label=islabel(m, 1, &quot;SHHMM&quot;),
            norm=:probability, bins=sim_range, errortype=:percentile, percentiles=QQ, fillalpha=0.3, centertype=:median, alpha=1, linewidth=2)
        annotate!(p_spell_rors[m], median(sim_range), 1.5, seasonname[m])
        yticks!(10.0 .^ (-4:-0))
    end

    pall = plot(p_spell_rors..., layout=(2, 2), size=(1000, 600), top_margin=0.34cm, left_margin=0.3cm, bottom_margin=0.22cm)
    file_name = &quot;ROR_spell_season_perc_$(perc)_Q_$(QQ[1])_$(QQ[2])_no_inset&quot;
    file_name = replace(file_name, &quot;.&quot; =&gt; &quot;p&quot;)
    pall
end</code></pre><img src="f87ee7dd.svg" alt="Example block output"/><h3 id="Rain"><a class="docs-heading-anchor" href="#Rain">Rain</a><a id="Rain-1"></a><a class="docs-heading-anchor-permalink" href="#Rain" title="Permalink"></a></h3><h4 id="Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k."><a class="docs-heading-anchor" href="#Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k.">Interpretation: Mean Rain per weather regime <span>$R &gt; 0 \mid Z = k$</span>.</a><a id="Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k.-1"></a><a class="docs-heading-anchor-permalink" href="#Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k." title="Permalink"></a></h4><p>We plot the empirical (strictly) positive <strong>mean</strong> rainfall amounts per weather regime. The results are smoothed using a <code>cyclic_moving_average</code> with a time window of <span>$\pm 15$</span> days and the Epanechnikov kernel.</p><pre><code class="language-julia hljs">begin
    p_rainpercat = [plot(tickfont=12, ylabelfontsize=14, titlefontsize=14, legendfontsize=13) for j = 1:D]
    for j = 1:D
        df_j = @chain data_stations_z[j] begin
            dropmissing
            @transform(:day = dayofyear_Leap.(:DATE))
            @subset(:RR .&gt; 0)
            @by([:day, :z], :MEAN_RR = mean(:RR))
            groupby(:z)
        end
        # Uncomment to see how the double exponential mixtures compare to the empirical data.
        # [plot!(p_rainpercat[j], 1:T, t -&gt; conversion_factor * mean(mix_allE[j][k, t]), label=:none, c=my_color(k, K), lw=1.5, legend = :topleft) for k in 1:K]
        for k in 1:K
            cycle_avg = replace(cyclic_moving_average(df_j[k].MEAN_RR, df_j[k].day, T, 15), 0 =&gt; missing)
            @df df_j[k] plot!(p_rainpercat[j], 1:T, conversion_factor * cycle_avg, c=my_color(k, K), alpha=1, label=islabel(j, staid_lat[[4]], L&quot;Z = %$k&quot;), lw=1.5)
        end
        ylims!(p_rainpercat[j], 0, Inf)
    end
    [ylabel!(p_rainpercat[j], &quot;Rain (mm)&quot;) for j in staid_lat[[1, 6]]]
    [xticks!(
        p_rainpercat[j],
        vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366),
        vcat(string.(first.(string.(monthabbr.(1:12)))))
    ) for j in 1:D]
    [title!(p_rainpercat[j], station_name[j]) for j = 1:D]
    plt_rain_cat_mix = plot(p_rainpercat[staid_lat]..., size=(3000 / 2.2, 1000 / 1.5), layout=(2, 5), left_margin=25px)
end</code></pre><img src="9212600c.svg" alt="Example block output"/><h4 id="Univariate-Rain-distributions"><a class="docs-heading-anchor" href="#Univariate-Rain-distributions">Univariate Rain distributions</a><a id="Univariate-Rain-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Rain-distributions" title="Permalink"></a></h4><p>Historical vs <code>Nb</code> simulations distribution</p><pre><code class="language-julia hljs">begin
    p_uniR = [plot(yaxis=:log10, ylims=(0.2e-4, 1e-0), tickfont=11, legendfontsize=13, titlefontsize=13) for j = 1:D]
    for j = 1:D
        dists_RR_positive_j = conversion_factor * [filter(!iszero, rs[j, :, i]) for i in 1:Nb]
        Rmax = ceil(max(dists_RR_positive_j .|&gt; maximum |&gt; maximum, conversion_factor * filter(!iszero, data_stations[j].RR) |&gt; maximum))
        BINS = 0:2:Rmax # fixing the bins is very important to ensure fair comparison. Note that changing the bin step changes the aspect of the distributions.
        errorlinehist!(p_uniR[j], dists_RR_positive_j, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:pdf, errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median, bins = BINS)

        errorlinehist!(p_uniR[j], dists_RR_positive_j, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:pdf, errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median, bins = BINS)

        errorlinehist!(p_uniR[j], [conversion_factor * filter(!iszero, data_stations[j].RR)], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:pdf, errortype=:percentile, bins = BINS, alpha = 0.7)

        xlims!(p_uniR[j], 0.0, Inf)
    end
    [plot!(p_uniR[j], xlabel=&quot;Rain (mm)&quot;) for j in staid_lat[6:10]]
    [plot!(p_uniR[j], ylabel=&quot;PDF&quot;) for j in staid_lat[[1, 6]]]

    [title!(p_uniR[j], station_name[j]) for j = 1:D]

    pall_R = plot(p_uniR[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), bottom_margin=11px, left_margin=15px)
end</code></pre><img src="dc1d046f.svg" alt="Example block output"/><p>Aggregated 5 days <code>RR</code> distribution</p><pre><code class="language-julia hljs">agg_window = 5
df_res = [
    @chain df[1+local_order:end, :] begin
    @transform(:agg = first.(divrem.(1:N, agg_window)))
    @by(:agg, :AGG = sum(:RR) * 0.1)
    end
        for df in data_stations_z
            ]


agg_i_full = first.(divrem.(1:N, agg_window))
idx_agg = [findall(agg_i_full .== val) for val in unique((agg_i_full))]
agg_rs = [[sum(rs[j, ii, i]) for ii in idx_agg] for j in 1:D, i in 1:Nb] * conversion_factor
agg_RR = [[sum(RR[ii, j]) for ii in idx_agg] for j in 1:D]
begin
    p_uniR = [plot(yaxis=:log10, ylims=(3e-5, 2e-1), tickfont=11, legendfontsize=13, titlefontsize=13, legend=:bottom) for j = 1:D]
    [plot!(p_uniR[j], xlabel=&quot;$(agg_window) days rain (mm)&quot;) for j in staid_lat[6:10]]
    [plot!(p_uniR[j], ylabel=&quot;PDF&quot;) for j in staid_lat[[1, 6]]]
    [title!(p_uniR[j], station_name[j]) for j = 1:D]
    for j = 1:D
        dists_RR_positive_j = agg_rs[j, :]
        Rmax = ceil(max(agg_rs[j, :] .|&gt; maximum |&gt; maximum, agg_RR[j] |&gt; maximum))
        errorlinehist!(p_uniR[j], dists_RR_positive_j, groupcolor=:grey, legend=:topright, label=islabel(j, 20, L&quot;Simu $q_{0,100}$&quot;), norm=:pdf, errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median, bins=0:3:Rmax)

        errorlinehist!(p_uniR[j], dists_RR_positive_j, groupcolor=:red, label=islabel(j, 20, L&quot;Simu $q_{25,75}$&quot;), norm=:pdf, errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median, bins=0:3:Rmax)

        errorlinehist!(p_uniR[j], [agg_RR[j]], label=islabel(j, 20, &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:pdf, errortype=:percentile, bins=0:3:Rmax, fillalpha=0.8)

        xlims!(p_uniR[j], 0.0, Inf)
        yticks!(10.0 .^ (-5:-1))
        lens!(p_uniR[j], [0, 25], [0.0, 0.2], inset=(1, bbox(0.48, -0, 0.475, 0.25)), linewidth=0)
    end

    pall_aggR = plot(p_uniR[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), bottom_margin=14px, left_margin=15px)
    plot!(pall_aggR, (1:3)&#39;, inset=(1, bbox(2.4, 0.42, 0.6, 0.3)), subplot=2D + 1, legendfontsize=14, framestyle=:none, label=[L&quot;Simu $q_{0,100}$&quot; L&quot;Simu $q_{25,75}$&quot; &quot;Obs&quot;], c=[:gray :red :blue], foreground_color_legend=nothing, lw=2)
end</code></pre><img src="1c048094.svg" alt="Example block output"/><h4 id="Autocorrelation"><a class="docs-heading-anchor" href="#Autocorrelation">Autocorrelation</a><a id="Autocorrelation-1"></a><a class="docs-heading-anchor-permalink" href="#Autocorrelation" title="Permalink"></a></h4><pre><code class="language-julia hljs">acfrange = 0:15
@views aa = [autocor(rs[j, :, i], acfrange) for j in 1:D, i in 1:Nb]

begin
    p_spell_wet = [plot(xlabelfontsize=16, ylabelfontsize=16, tickfont=11, legendfontsize=16) for j = 1:D]
    for j = 1:D
        errorline!(p_spell_wet[j], acfrange, stack(aa[:, j], dims=1)&#39;, groupcolor=:gray, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), errortype=:percentile, percentiles=[0, 100], fillalpha=0.8, lw=2, centertype=:median)
        plot!(p_spell_wet[j], acfrange, autocor(RR[:, j], acfrange), label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), lw=2.0, c=1, markers=:circle, alpha=0.8)
    end

    [xlabel!(p_spell_wet[j], &quot;Lag&quot;, xlabelfontsize=12) for j in staid_lat[6:10]]
    [ylabel!(p_spell_wet[j], &quot;ACF&quot;, ylabelfontsize=12) for j in staid_lat[[1, 6]]]
    [title!(p_spell_wet[j], station_name[j], titlefontsize=13) for j = 1:D]
    pall_ACF = plot(p_spell_wet[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), left_margin=0.42cm, bottom_margin=0.32cm)
end</code></pre><img src="5ed707c4.svg" alt="Example block output"/><h4 id="Monthly-quantile-amount"><a class="docs-heading-anchor" href="#Monthly-quantile-amount">Monthly quantile amount</a><a id="Monthly-quantile-amount-1"></a><a class="docs-heading-anchor-permalink" href="#Monthly-quantile-amount" title="Permalink"></a></h4><pre><code class="language-julia hljs">rh = reduce(hcat, [df[1+local_order:end, :RR] for df in data_stations])

month_rain_simu = [monthly_agg(rs[j, :, i], idx_all) for j in 1:D, i in 1:Nb];

month_rain_histo = [monthly_agg(rh[:, j], idx_all) for j in 1:D]

qs = [0.9, 0.5, 0.1]

@time &quot;Plot monthly quantile&quot; begin
    p_month_RR = [scatter(xtickfontsize=10, ytickfontsize=11, ylabelfontsize=12, legendfontsize = 12, foreground_color_legend=nothing) for j = 1:D]
    for j = 1:D
        for (α, per) in enumerate([[0, 100], [25, 75]])
            for (cc, q) in enumerate(qs)
                errorline!(p_month_RR[j], [quantile(month_rain_simu[j, i][:, m], q) * conversion_factor for m in 1:12, i in 1:Nb], label=(α == 1 ? islabel(j, 9,L&quot;Simu  $q_{%$(Int(q*100))}$&quot;) : :none), fillalpha=0.18 * α^2, centertype=:median, errortype=:percentile, percentiles=per, groupcolor=my_palette(length(qs))[cc])
            end
        end
        for q in qs
            scatter!(p_month_RR[j], m -&gt; quantile(month_rain_histo[j][:, m], q) * conversion_factor, 1:12, label=(q == qs[1] ? islabel(j, 3,&quot;Obs&quot;) : :none), legend = :topleft, ms=2.5, c=:blue)
            plot!(p_month_RR[j], m -&gt; quantile(month_rain_histo[j][:, m], q) * conversion_factor, 1:12, label=:none, c=:blue, lw=1.75)
        end
        xticks!(p_month_RR[j], 1:12, string.(first.(monthabbr.(1:12))))
        ylims!(p_month_RR[j], 0, Inf)
    end
    [ylabel!(p_month_RR[j], &quot;Rain (mm)&quot;) for j in staid_lat[[1, 6]]]

    [title!(p_month_RR[j], station_name[j], titlefontsize=12) for j = 1:D]
    pall_month_RR = plot(p_month_RR[staid_lat]..., size=(1190, 500), layout=(2, 5), left_margin=19px)
end</code></pre><img src="9731ef85.svg" alt="Example block output"/><h3 id="Correlations"><a class="docs-heading-anchor" href="#Correlations">Correlations</a><a id="Correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Correlations" title="Permalink"></a></h3><h5 id="Rain-event-dry/wet"><a class="docs-heading-anchor" href="#Rain-event-dry/wet">Rain event dry/wet</a><a id="Rain-event-dry/wet-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-event-dry/wet" title="Permalink"></a></h5><pre><code class="language-julia hljs">cor_bin_hist = cor(reduce(hcat, [df.RO for df in data_stations]));

cor_bin_mean_simu = mean(cor(ys[:, :, i]) for i in 1:Nb);


begin
    plots_cor_bin = [plot(-0.1:0.1:0.8, -0.1:0.1:0.8, aspect_ratio=true, label=:none, xlabelfontsize=16, ylabelfontsize=16, tickfont=11, legendfontsize=13) for _ in 1:1]
    scatter!(plots_cor_bin[1], vec_triu(cor_bin_hist), vec_triu(cor_bin_mean_simu), label=&quot;Correlations&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=2)
    [xlims!(plots_cor_bin[i], -0.1, 1) for i in 1:1]
    [ylims!(plots_cor_bin[i], -0.1, 1) for i in 1:1]
    annotate!(0.2, 0.7, &quot;MSE ≃ $(round(mean(abs2, vec_triu(cor_bin_hist) - vec_triu(cor_bin_mean_simu)), digits = 4))&quot;)
    plot_cor_bin = plot(plots_cor_bin...)
end</code></pre><img src="5915a2f7.svg" alt="Example block output"/><p>The largest pair correlation error for rain occurrence comes from the pair</p><pre><code class="language-julia hljs">println(&quot;$(station_name[findmax(cor_bin_hist - cor_bin_mean_simu)[2][1]]) and $(station_name[findmax(cor_bin_hist - cor_bin_mean_simu)[2][2]])&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CHASSIRON and LA HAGUE</code></pre><h5 id="Rainfall-amount"><a class="docs-heading-anchor" href="#Rainfall-amount">Rainfall amount</a><a id="Rainfall-amount-1"></a><a class="docs-heading-anchor-permalink" href="#Rainfall-amount" title="Permalink"></a></h5><pre><code class="language-julia hljs">cor_hist = cor(reduce(hcat, [df.RR for df in data_stations]));

corT_hist = corTail(reduce(hcat, [df.RR for df in data_stations]));

cor_mean_simu = mean(cor(rs[:, :, i]&#39;) for i in 1:Nb);

corT_mean_simu = mean(corTail(rs[:, :, i]&#39;) for i in 1:Nb);

begin
    plots_cor = [plot(-0.1:0.1:0.8, -0.1:0.1:0.8, aspect_ratio=true, label=:none, xlabelfontsize=16, ylabelfontsize=16, tickfont=11, legendfontsize=13) for _ in 1:2]
    scatter!(plots_cor[1], vec_triu(cor_hist), vec_triu(cor_mean_simu), label=&quot;Correlations&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=2)
    annotate!(plots_cor[1], 0.3, 0.7, &quot;MSE ≃ $(round(mean(abs2, vec_triu(cor_hist) - vec_triu(cor_mean_simu)), digits = 4))&quot;)

    scatter!(plots_cor[2], vec_triu(corT_hist), vec_triu(corT_mean_simu), label=&quot;Tail index&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=3)
    annotate!(plots_cor[2], 0.3, 0.7, &quot;MSE ≃ $(round(mean(abs2, vec_triu(corT_hist) - vec_triu(corT_mean_simu)), digits = 4))&quot;)

    [xlims!(plots_cor[i], -0.1, 1) for i in 1:2]
    [ylims!(plots_cor[i], -0.1, 1) for i in 1:2]
    plot_cor_all = plot(plots_cor..., size=(800, 400), left_margin=15px, right_margin = 8px)
end</code></pre><img src="bd9058c8.svg" alt="Example block output"/><p>The largest pair correlation error for rain (zero and non zero amounts) comes from the pair</p><pre><code class="language-julia hljs">println(&quot;$(station_name[findmax(cor_hist - cor_mean_simu)[2][1]]) and $(station_name[findmax(cor_hist - cor_mean_simu)[2][2]])&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EMBRUN and MARIGNANE</code></pre><h5 id="Gaussian-copula-hypothesis"><a class="docs-heading-anchor" href="#Gaussian-copula-hypothesis">Gaussian copula hypothesis</a><a id="Gaussian-copula-hypothesis-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-copula-hypothesis" title="Permalink"></a></h5><p>For a pair of stations, we transform the marginal <span>$R_s&gt;0$</span> to <span>$\mathcal{N}(0,1)$</span>. We compare the obtained bi-variate Normal distribution with the Mahalanobis distance to the theoretical <span>$\chi^2(2)$</span>-distriubtion.</p><pre><code class="language-julia hljs">corΣ = cov2cor.(Σ²RR)
begin
    j1 = 10
    j2 = 8
    plt_qqp_copula = plot(0:25, 0:25, aspect_ratio=:equal, legendfontsize=14, c=:black, label=:none, tickfont=12, ylabelfontsize=13, xlabelfontsize=13)
    df_12 = leftjoin(data_stations_z[j1], data_stations_z[j2], on=:DATE, makeunique=true)
    @subset!(df_12, :RR .&gt; 0, :RR_1 .&gt; 0)
    for k in 1:K
        df_X = @chain df_12 begin
            @subset(:z .== k)
            dropmissing
            @aside u = StochasticWeatherGenerators.Copulas.pseudos(permutedims(hcat(_.RR, _.RR_1)))
            @transform(:X = quantile(Normal(), u[1,:]), :X_1 = quantile(Normal(), u[2,:]))
        end
        X = hcat(df_X.X, df_X.X_1)
        cor_sigma = [1 corΣ[k][j1,j2]; corΣ[k][j1,j2] 1]
        Σ⁻¹ = inv(cor_sigma)

        X2 = [(x&#39; * Σ⁻¹ * x) for x in eachrow(X)] |&gt; sort
        ecdfX2 = ecdf(X2)(X2) * length(X2) / (length(X2) + 1)

        plot!(quantile(Chisq(2), ecdfX2), X2, xlabel=L&quot;$\chi^2(2)$-quantile&quot;, c=my_color(k, K), ylabel=&quot;Observed squared Mahalanobis distance&quot;, label=L&quot;Z = %$k &quot;, legend=:topleft, lw=2)
    end
    title!(&quot;$(station_name[j1])-$(station_name[j2]) $(ifelse(j1 == 10 &amp;&amp; j2 == 8, &quot;(334 km)&quot;, &quot;&quot;))&quot;)
    xlims!(0, 22)
    ylims!(0, 22)
end</code></pre><img src="c72c87ca.svg" alt="Example block output"/><h2 id="Reproducibility"><a class="docs-heading-anchor" href="#Reproducibility">Reproducibility</a><a id="Reproducibility-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducibility" title="Permalink"></a></h2><pre><code class="language-julia hljs">using InteractiveUtils
InteractiveUtils.versioninfo()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.11.6
Commit 9615af0f269 (2025-07-09 12:58 UTC)
Build Info:
  Official https://julialang.org/ release
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 4 × AMD EPYC 7763 64-Core Processor
  WORD_SIZE: 64
  LLVM: libLLVM-16.0.6 (ORCJIT, znver3)
Threads: 1 default, 0 interactive, 1 GC (on 4 virtual cores)
Environment:
  JULIA_DEBUG = Documenter</code></pre><p>Package list and version</p><pre><code class="language-julia hljs">import Pkg; Pkg.status()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Status `~/work/StochasticWeatherGenerators.jl/StochasticWeatherGenerators.jl/docs/Project.toml`
  [336ed68f] CSV v0.10.15
⌃ [13f3f980] CairoMakie v0.13.10
  [a93c6f00] DataFrames v1.7.0
  [1313f7d8] DataFramesMeta v0.15.4
  [8bb1440f] DelimitedFiles v1.9.1
  [31c24e10] Distributions v0.25.120
  [e30172f5] Documenter v1.14.1
  [daee34ce] DocumenterCitations v1.4.0
  [db073c08] GeoMakie v0.7.13
  [4138dd39] JLD v0.13.5
  [b964fa9f] LaTeXStrings v1.4.0
  [98b081ad] Literate v2.20.1
  [436b0209] NaturalEarth v0.1.0
  [bac558e1] OrderedCollections v1.8.1
  [3d8e1505] SmoothPeriodicStatsModels v2.0.3
  [2913bbd2] StatsBase v0.34.5
  [f3b207a7] StatsPlots v0.15.7
  [3eadb0b9] StochasticWeatherGenerators v1.3.1 `~/work/StochasticWeatherGenerators.jl/StochasticWeatherGenerators.jl`
  [fd094767] Suppressor v0.2.8
  [ade2ca70] Dates v1.11.0
  [b77e0a4c] InteractiveUtils v1.11.0
  [9a3f8284] Random v1.11.0
Info Packages marked with ⌃ have new versions available and may be upgradable.</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../data/">« 📅 Weather Data</a><a class="docs-footer-nextpage" href="../tuto_add_station_variable/">Multivariate SWG: Application to crop model »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/dmetivie/StochasticWeatherGenerators.jl">StochasticWeatherGenerators.jl</a> v1.3.1 docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 14 July 2025 21:54">Monday 14 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
