<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multisite daily Stochastic Weather Generator · StochasticWeatherGenerators</title><meta name="title" content="Multisite daily Stochastic Weather Generator · StochasticWeatherGenerators"/><meta property="og:title" content="Multisite daily Stochastic Weather Generator · StochasticWeatherGenerators"/><meta property="twitter:title" content="Multisite daily Stochastic Weather Generator · StochasticWeatherGenerators"/><meta name="description" content="Documentation for StochasticWeatherGenerators."/><meta property="og:description" content="Documentation for StochasticWeatherGenerators."/><meta property="twitter:description" content="Documentation for StochasticWeatherGenerators."/><meta property="og:url" content="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><meta property="twitter:url" content="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><link rel="canonical" href="https://dmetivie.github.io/StochasticWeatherGenerators.jl/examples/tuto_paper/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="StochasticWeatherGenerators logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StochasticWeatherGenerators</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">StochasticWeatherGenerators.jl</a></li><li class="is-active"><a class="tocitem" href>Multisite daily Stochastic Weather Generator</a><ul class="internal"><li><a class="tocitem" href="#Set-up"><span>Set up</span></a></li><li><a class="tocitem" href="#HMM-Hyperparameters"><span>HMM Hyperparameters</span></a></li><li><a class="tocitem" href="#Data"><span>Data</span></a></li><li><a class="tocitem" href="#Fit-the-seasonal-HMM"><span>Fit the seasonal HMM</span></a></li><li><a class="tocitem" href="#Adding-Rain-amounts-to-the-model"><span>Adding Rain amounts to the model</span></a></li><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li><li><a class="tocitem" href="#Results"><span>Results</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Multisite daily Stochastic Weather Generator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multisite daily Stochastic Weather Generator</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dmetivie/StochasticWeatherGenerators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dmetivie/StochasticWeatherGenerators.jl/blob/master/examples/tuto_paper.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multisite-daily-Stochastic-Weather-Generator"><a class="docs-heading-anchor" href="#Multisite-daily-Stochastic-Weather-Generator">Multisite daily Stochastic Weather Generator</a><a id="Multisite-daily-Stochastic-Weather-Generator-1"></a><a class="docs-heading-anchor-permalink" href="#Multisite-daily-Stochastic-Weather-Generator" title="Permalink"></a></h1><p>This tutorial describes the numerical applications described in the paper <a href="https://hal.inrae.fr/hal-04621349"><em>Interpretable Seasonal Hidden Markov Model for spatio-temporal stochastic rain generation in France</em></a> by <a href="http://www.cmap.polytechnique.fr/~gobet/">Emmanuel Gobet</a> (CMAP - École Polytechnique), <a href="https://davidmetivier.mistea.inrae.fr/">David Métivier</a> (MISTEA – INRAE) and <a href="https://fr.linkedin.com/in/sylvie-parey-60285194">Sylvie Parey</a> (R&amp;D – EDF). It shows a fully reproducible example on how to use the package <code>StochasticWeatherGenerators.jl</code> to reproduce, step-by-step, exactly (almost) all the figures of the paper.</p><p>The paper describes the construction of a Stochastic Weather Generator with an Autoregressive Seasonal Hidden Markov Model (SHMM). The SHMM is trained with French weather stations, and the hidden states are interpreted as weather regimes. The model is validated with simulations, especially for its ability to reproduce extreme weather, e.g. droughts. In the paper, the model is also used with Climate Change RCP scenarios (not shown here).</p><img src="https://github.com/dmetivie/StochasticWeatherGenerators.jl/assets/46794064/5fe1d677-877d-4fd5-83ac-29d30f728ca5" width="95%" alt = "Schematic of the Autoregressive Seasonal Hidden Markov Model"/><h2 id="Set-up"><a class="docs-heading-anchor" href="#Set-up">Set up</a><a id="Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up" title="Permalink"></a></h2><h3 id="Package-and-functions"><a class="docs-heading-anchor" href="#Package-and-functions">Package and functions</a><a id="Package-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Package-and-functions" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">For Julia new user</header><div class="admonition-body"><p>There are several ways to <code>add</code> a package before <code>using</code>, one way is for this tutorial to copy-paste (it might take a while):</p><pre><code class="language-julia hljs">import Pkg
Pkg.add([&quot;CSV&quot;, &quot;JLD&quot;, &quot;DelimitedFiles&quot;, &quot;DataFrames&quot;, &quot;DataFramesMeta&quot;, &quot;StatsBase&quot;, &quot;Random&quot;, &quot;Distributions&quot;, &quot;StatsPlots&quot;, &quot;LaTeXStrings&quot;])</code></pre></div></div><pre><code class="language-julia hljs">using CSV, JLD, DelimitedFiles # File Read/Load/Save

using DataFrames, DataFramesMeta # DataFrames

using Dates

using StatsBase, Random

using Distributions</code></pre><p>The two main packages for this tutorial are not yet registered in the official Julia registry, since they are not quite fully ready. They can be either <code>add</code>ed through <a href="https://github.com/dmetivie/LocalRegistry">my local Julia registry</a> with the <a href="https://github.com/GunnarFarneback/LocalRegistry.jl">LocalRegistry.jl</a> package i.e.</p><pre><code class="language-julia hljs">using Pkg
pkg&quot;registry add https://github.com/dmetivie/LocalRegistry&quot;
Pkg.add(&quot;SmoothPeriodicStatsModels&quot;)
Pkg.add(&quot;StochasticWeatherGenerators&quot;)</code></pre><p>Or directly on the master branch with <code>add</code>ed via url i.e.</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(url = &quot;https://github.com/dmetivie/SmoothPeriodicStatsModels.jl&quot;)
Pkg.add(url = &quot;https://github.com/dmetivie/StochasticWeatherGenerators.jl&quot;)</code></pre><pre><code class="language-julia hljs">using SmoothPeriodicStatsModels # Name might change. Small collection of smooth periodic models e.g. AR, HMM

using StochasticWeatherGenerators # interface to use with SmoothPeriodicStatsModels.jl</code></pre><pre><code class="language-julia hljs">Random.seed!(1234)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.TaskLocalRNG()</code></pre><h3 id="Settings-for-plotting"><a class="docs-heading-anchor" href="#Settings-for-plotting">Settings for plotting</a><a id="Settings-for-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Settings-for-plotting" title="Permalink"></a></h3><p>Some settings and packages to have nice plots.</p><pre><code class="language-julia hljs">using StatsPlots, LaTeXStrings
using StatsPlots.PlotMeasures # To play with margin in Plots

gr() # plotly() # for interactive plots
default(fontfamily=&quot;Computer Modern&quot;)
cur_colors = get_color_palette(:auto, 100);
my_palette(K) = palette(vcat(cur_colors[1], [cur_colors[c] for c in 3:4], cur_colors[2]), K)

file_for_plot_utilities = download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/examples/utilities_plot.jl&quot;)
include(file_for_plot_utilities)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cyclic (generic function with 1 method)</code></pre><p>To plot maps, we use <code>GeoMakie.jl</code> + <code>NaturalEarth.jl</code>. Note that using <code>cartopy</code> with <code>PyCall.jl</code> also works very well.</p><p>For the following code to work you will need to add the following packages</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(&quot;NaturalEarth&quot;, &quot;GeoMakie&quot;, &quot;CairoMakie&quot;)</code></pre><pre><code class="language-julia hljs">file_for_maps_with_geomakie = download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/examples/utilities_geo_makie_features.jl&quot;) # download file from a GitHub repo
include(file_for_maps_with_geomakie)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">savefigcrop (generic function with 4 methods)</code></pre><h3 id="Global-Parameters"><a class="docs-heading-anchor" href="#Global-Parameters">Global Parameters</a><a id="Global-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Parameters" title="Permalink"></a></h3><p>Number of days in a year (choice here is 366)</p><pre><code class="language-julia hljs">T = 366</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">366</code></pre><p>Define the French area for map (Longitude and latitude) plot and the precision of the map <code>precision_scale</code></p><pre><code class="language-julia hljs">precision_scale = 50 # meter

LON_min = -5 # West

LON_max = 10 # East

LAT_min = 41 # South

LAT_max = 52 # North</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">52</code></pre><p><code>conversion_factor</code> for rain amounts <code>RR</code> in 0.1 mm to mm</p><pre><code class="language-julia hljs">conversion_factor = 0.1 # 0.1 mm -&gt; mm</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.1</code></pre><h2 id="HMM-Hyperparameters"><a class="docs-heading-anchor" href="#HMM-Hyperparameters">HMM Hyperparameters</a><a id="HMM-Hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#HMM-Hyperparameters" title="Permalink"></a></h2><p>Number of hidden states</p><pre><code class="language-julia hljs">K = 4

my_pal = my_palette(K); # just colors I like for plotting weather regime!</code></pre><p>Degree <code>𝐃𝐞𝐠</code> of the trigonometric expansion It could be an array different for each station and variable. Not implemented yet though.</p><pre><code class="language-julia hljs">𝐃𝐞𝐠 = 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>Local memory order i.e. at station <span>$j$</span>, <span>$\mathbb{P}(Y_n^{(j)} = y_n^{(j)} \mid Z = k, Y_{n-1:n-\texttt{local memory}}^{(j)} = y_{n-1:n-\texttt{local memory}}^{(j)})$</span></p><pre><code class="language-julia hljs">local_order = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>local_order</code> and/or <code>𝐃𝐞𝐠</code> could be a vector/matrix of size <code>D</code> and different for each station, and also different depending on wet or dry past. Not yet implemented.</p></div></div><pre><code class="language-julia hljs">size_order = 2^local_order

println(&quot;K = $K, &quot;, &quot;local_order = $local_order, &quot;, &quot;degree = $𝐃𝐞𝐠&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">K = 4, local_order = 1, degree = 2</code></pre><h2 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h2><h3 id="Select-relevant-stations-from-the-station.txt-file"><a class="docs-heading-anchor" href="#Select-relevant-stations-from-the-station.txt-file">Select relevant stations from the <code>station.txt</code> file</a><a id="Select-relevant-stations-from-the-station.txt-file-1"></a><a class="docs-heading-anchor-permalink" href="#Select-relevant-stations-from-the-station.txt-file" title="Permalink"></a></h3><p>Here we</p><ul><li>Remove white space at the right of the <code>CN</code>, STANAME which is caused by imperfect CVS importation</li><li>Select only the stations with 100% valid data for the period <code>Date(1955,12,31) .≤ :DATE .≤ Date(2019,12,31)</code></li><li>Shorten station names</li></ul><pre><code class="language-julia hljs">begin
    station_file = Base.download(&quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/weather_files/stations.txt&quot;)
    station_all = CSV.read(station_file, DataFrame, header=18, normalizenames=true, ignoreemptyrows=true)
    station_all = @chain station_all begin
        @transform(:CN = rstrip.(:CN), :STANAME = rstrip.(:STANAME))
        # @subset(:CN .∈ tuple([&quot;FR&quot;, &quot;BE&quot;, &quot;LU&quot;, &quot;CH&quot;])) # Choose that if you want to look at all stations in France, Belgium, Luxembourg and Switzerland.
        @subset(:STAID .∈ tuple([32, 33, 34, 36, 39, 203, 322, 323, 434, 736, 737, 738, 740, 742, 745, 749, 750, 755, 756, 757, 758, 786, 793, 2192, 2203, 2205, 2207, 2209, 11244, 11245, 11247, 11249]))
        @transform(:STANAME = shortname.(:STANAME))
    end
end

selected_station_name = [&quot;BOURGES&quot;, &quot;TOULOUSE&quot;, &quot;MARIGNANE&quot;, &quot;LUXEMBOURG&quot;, &quot;LILLE&quot;, &quot;EMBRUN&quot;, &quot;BASTIA&quot;, &quot;LA HAGUE&quot;, &quot;CHASSIRON&quot;, &quot;ORLY&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{String}:
 &quot;BOURGES&quot;
 &quot;TOULOUSE&quot;
 &quot;MARIGNANE&quot;
 &quot;LUXEMBOURG&quot;
 &quot;LILLE&quot;
 &quot;EMBRUN&quot;
 &quot;BASTIA&quot;
 &quot;LA HAGUE&quot;
 &quot;CHASSIRON&quot;
 &quot;ORLY&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Hypothesis: Conditional Independence of Rain Occurrences</header><div class="admonition-body"><p>You can change the selected stations. However, keep in mind that for the model to work, the <strong>conditional independence hypothesis</strong> must hold between stations i.e. <span>$\mathbb{P}(Y_1 = y_1, \cdots, Y_S = y_s\mid Z = k) = \prod_{s=1}^S \mathbb{P}(Y_s = y_s)$</span>. Hence stations must be sufficiently far apart. Check out this <a href="https://dmetivie.github.io/ExpectationMaximization.jl/dev/examples/#MNIST-dataset:-Bernoulli-Mixture">MNIST example</a> to see Bernoulli mixtures in action!</p></div></div><pre><code class="language-julia hljs">station = @subset(station_all, :STANAME .∈ tuple(selected_station_name))

STAID = station.STAID #[32, 33, 39, 203, 737, 755, 758, 793, 11244, 11249];

station_name = station.STANAME</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{SubString{String}}:
 &quot;BOURGES&quot;
 &quot;TOULOUSE&quot;
 &quot;MARIGNANE&quot;
 &quot;LUXEMBOURG&quot;
 &quot;LILLE&quot;
 &quot;EMBRUN&quot;
 &quot;BASTIA&quot;
 &quot;LA HAGUE&quot;
 &quot;CHASSIRON&quot;
 &quot;ORLY&quot;</code></pre><p>Sort stations (index) by latitude. It is useful for plotting from North to South.</p><pre><code class="language-julia hljs">staid_lat = sortperm(station.LAT, rev=true);</code></pre><p>Station number</p><pre><code class="language-julia hljs">D = length(STAID)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10</code></pre><h3 id="Date-range"><a class="docs-heading-anchor" href="#Date-range">Date range</a><a id="Date-range-1"></a><a class="docs-heading-anchor-permalink" href="#Date-range" title="Permalink"></a></h3><pre><code class="language-julia hljs">date_start = Date(1956)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1956-01-01</code></pre><p>Date including the previous days used in the initial condition (in case <code>local_memory &gt; 0</code>)</p><pre><code class="language-julia hljs">date_start_w_memory = date_start - Day(local_order)

date_end = Date(2020) - Day(1)

every_year = date_start:Day(1):date_end

every_year_w_memory = date_start_w_memory:Day(1):date_end

n2t = dayofyear_Leap.(every_year)

N = length(n2t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">23376</code></pre><h3 id="Treat-data"><a class="docs-heading-anchor" href="#Treat-data">Treat data</a><a id="Treat-data-1"></a><a class="docs-heading-anchor-permalink" href="#Treat-data" title="Permalink"></a></h3><p>Load into a <code>DataFrame</code> the (ECA) RR files (rain). It filters by date and valid data. It also adds a column <code>:bin</code> for rain events (0: dry, 1: wet).</p><pre><code class="language-julia hljs">begin
    data_stations = collect_data_ECA.(STAID, date_start_w_memory, date_end, &quot;https://raw.githubusercontent.com/dmetivie/StochasticWeatherGenerators.jl/master/weather_files/ECA_blend_rr/RR_&quot;, portion_valid_data=1, skipto=22, header=21, url=true)
    for i = eachindex(data_stations)
        @transform!(data_stations[i], :bin = onefy.(:RR))
    end
end</code></pre><p>Binary matrix version of the rain event at the <code>D</code> stations.</p><pre><code class="language-julia hljs">Yall = BitMatrix(reduce(hcat, [data_stations[j].bin for j = 1:D]))

Y_past = BitMatrix(Yall[1:local_order, :]) # rand(Bool, local_order, D)

ξ = [1; zeros(K - 1)];  # 1 jan 1956 was most likely a type Z = 1 wet day all over France

Y = Yall[1+local_order:end, :]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">23376×10 BitMatrix:
 1  1  1  1  1  1  1  1  1  1
 1  1  0  1  1  0  1  0  1  0
 0  0  0  0  0  0  1  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  1  1  0  0  0  0  0  0  1
 1  1  1  0  1  0  1  1  1  1
 1  1  1  1  1  1  0  0  1  1
 0  1  1  1  1  1  1  1  1  0
 1  0  0  1  1  1  0  1  1  1
 ⋮              ⋮           
 1  1  0  1  1  1  0  1  1  1
 1  0  0  1  1  0  0  0  0  0
 0  0  0  1  0  0  0  1  1  0
 1  0  0  1  1  0  0  1  0  1
 1  0  0  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  1  0
 0  0  0  0  1  0  0  0  1  0
 0  0  0  0  0  0  0  0  1  0
 0  0  0  0  0  0  0  0  1  0</code></pre><h3 id="Map-of-stations"><a class="docs-heading-anchor" href="#Map-of-stations">Map of stations</a><a id="Map-of-stations-1"></a><a class="docs-heading-anchor-permalink" href="#Map-of-stations" title="Permalink"></a></h3><p>Convert LAT/LON coordinates from DMS to DD which seems most widely accepted format.</p><pre><code class="language-julia hljs">LAT_idx = dms_to_dd.(station.LAT)

LON_idx = dms_to_dd.(station.LON)

long_spell = [longuest_spell(y) for y in eachcol(Y)]

FR_map_spell = map_with_stations(LON_idx, LAT_idx, long_spell; station_name=station_name, show_value=true, colorbar_show=true, precision_scale = precision_scale)</code></pre><img src="db010be4.png" alt="Example block output"/><h2 id="Fit-the-seasonal-HMM"><a class="docs-heading-anchor" href="#Fit-the-seasonal-HMM">Fit the seasonal HMM</a><a id="Fit-the-seasonal-HMM-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-the-seasonal-HMM" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Hypothesis: Smooth parameter evolution</header><div class="admonition-body"><p>We assume all models e.g. HMM, rain mixture to have parameters evolving smoothly with periodicity <span>$T$</span> for <span>$t \in [1, T]$</span>. For example a Bernoulli parameter will write</p><p class="math-container">\[p(t) = \dfrac{1}{1 + e^{P(t)}} \in [0, 1],\]</p><p>with</p><p class="math-container">\[    P_c(t) = c_0 + \sum_{j=1}^{\texttt{Deg}} \left(c_{2j-1}\cos\left(\dfrac{2\pi}{T}j t\right) + c_{2j}\sin\left(\dfrac{2\pi}{T}j t\right)\right).\]</p></div></div><h3 id="Fit-slice:-naive-estimation"><a class="docs-heading-anchor" href="#Fit-slice:-naive-estimation">Fit slice: naive estimation</a><a id="Fit-slice:-naive-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-slice:-naive-estimation" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Before inferring the HMM parameters with the EM (Baum-Welch) algorithm, we do a first naive inference that will be used as initial condition for the EM.</p></div></div><p>The reference station <code>ref_station</code> is used to sort the hidden states obtained via the slide initialization Here we choose <code>j=1</code> <span>$\to$</span> <code>STAID=32</code> <span>$\to$</span> <code>BOURGES</code> because it is a central station for France</p><pre><code class="language-julia hljs">ref_station = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>This generates a random Periodic HMM that we then fit slice by slice (day by day). See paper.</p><pre><code class="language-julia hljs">hmm_random = randhierarchicalPeriodicHMM(K, T, D, local_order; ξ=ξ, ref_station=ref_station);

@time &quot;FitMLE SHMM (Slice)&quot; hmm_slice = fit_mle_all_slices(hmm_random, Y, Y_past; n2t=n2t, robust=true, rand_ini=true, Dirichlet_α=0.8, history=false, n_random_ini=1, Yₜ_extanted=[-12, -7, 0, 6, 13]);

θᴬ_slice, θᴮ_slice = fit_θ!(hmm_slice, 𝐃𝐞𝐠);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FitMLE SHMM (Slice): 30.563914 seconds (194.59 M allocations: 29.983 GiB, 11.13% gc time, 20.16% compilation time)

******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit https://github.com/coin-or/Ipopt
******************************************************************************</code></pre><h3 id="Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point"><a class="docs-heading-anchor" href="#Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point">Fit with Baum Welch using the slice estimate as a starting point</a><a id="Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-with-Baum-Welch-using-the-slice-estimate-as-a-starting-point" title="Permalink"></a></h3><p>With the Slice estimate as a good starting point for the full (seasonal) Baum Welch EM algorithm we fit the model!</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To accelerate the fitting procedure (especially for larger models or when testing various model hyperparameters), one can do</p><pre><code class="language-julia hljs">using Distributed
addprocs(10) # number of worker to add
@everywhere SmoothPeriodicStatsModels # load the pkg on each worker</code></pre><p>Then the fitting loop inside <code>fit_mle</code> will be distributed. See the <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#man-distributed">official Julia doc</a> for more info. On smaller models it does not worth it since adding workers add some compilation and communication time.</p></div></div><pre><code class="language-julia hljs">@time &quot;FitMLE SHMM (Baum Welch)&quot; hmm_fit, θq_fit, θy_fit, hist, histo_A, histo_B = fit_mle(hmm_slice, θᴬ_slice, θᴮ_slice, Y, Y_past,
    maxiter=10000, robust=true; display=:final, silence=true, tol=1e-3, θ_iters=true, n2t=n2t);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EM converged in 74 iterations, logtot = -116791.10200745627
FitMLE SHMM (Baum Welch): 60.404895 seconds (192.97 M allocations: 33.369 GiB, 7.00% gc time, 15.60% compilation time)</code></pre><p>Uncomment to load previously computed hmm</p><pre><code class="language-julia hljs"># hmm_infos = load(&quot;save_tuto_path/hmm_fit.jld&quot;)
# hmm_fit = hmm_infos[&quot;hmm&quot;]
# hist = hmm_infos[&quot;hist&quot;]
# θq_fit = hmm_infos[&quot;Q_param&quot;]
# θy_fit = hmm_infos[&quot;Y_param&quot;]</code></pre><h3 id="Visualization-of-the-HMM-parameters"><a class="docs-heading-anchor" href="#Visualization-of-the-HMM-parameters">Visualization of the HMM parameters</a><a id="Visualization-of-the-HMM-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-the-HMM-parameters" title="Permalink"></a></h3><h4 id="Transition-matrix"><a class="docs-heading-anchor" href="#Transition-matrix">Transition matrix</a><a id="Transition-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-matrix" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    pA = [plot(legendfont=14, foreground_color_legend=nothing, background_color_legend=nothing, legend_columns=4, tickfont=12, legendfontsize=16) for k in 1:K]
    for k in 1:K
        [plot!(pA[k], hmm_fit.A[k, l, :], c=my_color(l, K), label=L&quot;Q_{%$(k)\to %$(l)}&quot;, legend=:top, lw=1.75) for l in 1:K]
        hline!(pA[k], [0.5], c=:black, label=:none, s=:dot)
        xticks!(pA[k], vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366), vcat(string.(monthabbr.(1:12)), &quot;&quot;), xlims=(0, 367), ylims=(0, 1))
    end
    pallA = plot(pA..., size=(1000, 500))
end</code></pre><img src="453b1848.svg" alt="Example block output"/><h4 id="Rain-probabilities"><a class="docs-heading-anchor" href="#Rain-probabilities">Rain probabilities</a><a id="Rain-probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-probabilities" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    mm = 1
    jt = D
    pB = [plot(legendfont=14, title=&quot;$(station_name[j])&quot;, titlefontsize=17, tickfont=14, legendfontsize = 16) for j in 1:jt]
    for j in 1:jt
        [plot!(pB[j], succprob.(hmm_fit.B[k, :, j, mm]), c=my_color(k, K), label=islabel(j, 3, L&quot;\mathbb{P}(Y = \textrm{wet}\mid Z = %$k, H = \textrm{dry})&quot;), lw=2) for k in 1:K]
        hline!(pB[j], [0.5], c=:black, label=:none, s=:dot)
        xticks!(
            pB[j],
            vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366),
            vcat(string.(first.(monthabbr.(1:12))))
        )
        xlims!(pB[j], (0, 367))
        ylims!(pB[j], (0, 1))
    end
    pallB = plot(pB[staid_lat]..., size=(3000 / 2, 1000 / 1), layout=(2, 5))
end</code></pre><img src="773c25c0.svg" alt="Example block output"/><h4 id="Spatial-Rain-probability"><a class="docs-heading-anchor" href="#Spatial-Rain-probability">Spatial Rain probability</a><a id="Spatial-Rain-probability-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-Rain-probability" title="Permalink"></a></h4><pre><code class="language-julia hljs">memory_past_cat = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>h = 1 (day before dry) or 2 (day before wet) <span>$\mathbb{P}(Y = \text{Rain}\mid Z = k, H = h)$</span> with <code>h = memory_past_cat</code></p><p>For now there are some scale rendering issues due to an <a href="https://github.com/MakieOrg/GeoMakie.jl/issues/268">GeoMakie.jl issue</a> so it might be tiny.</p><pre><code class="language-julia hljs">p_FR_map_mean_prob = map_with_stations(LON_idx, LAT_idx, [[mean(succprob.(hmm_fit.B[k, :, j, memory_past_cat])) for j in 1:length(STAID)] for k in 1:K], colorbar_show=true, colorbar_title = L&quot;\mathbb{P}(Y = \text{Rain}\mid Z = k, H = 1)&quot;, precision_scale = precision_scale)</code></pre><img src="f2f77e81.png" alt="Example block output"/><h3 id="Inference-of-the-historical-hidden-states"><a class="docs-heading-anchor" href="#Inference-of-the-historical-hidden-states">Inference of the historical hidden states</a><a id="Inference-of-the-historical-hidden-states-1"></a><a class="docs-heading-anchor-permalink" href="#Inference-of-the-historical-hidden-states" title="Permalink"></a></h3><h4 id="Viterbi-algorithm"><a class="docs-heading-anchor" href="#Viterbi-algorithm">Viterbi algorithm</a><a id="Viterbi-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Viterbi-algorithm" title="Permalink"></a></h4><pre><code class="language-julia hljs">ẑ = viterbi(hmm_fit, Y, Y_past; n2t=n2t)

data_stations_z = map(data_stations) do df
    @transform(df, :z = [fill(missing, local_order); ẑ])
end

ẑ_per_cat = [findall(ẑ .== k) for k in 1:K]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Int64}}:
 [1, 7, 8, 12, 17, 23, 29, 44, 80, 81  …  23356, 23357, 23358, 23359, 23362, 23364, 23365, 23366, 23367, 23368]
 [2, 10, 11, 14, 18, 20, 21, 22, 25, 26  …  23323, 23327, 23328, 23333, 23351, 23352, 23355, 23360, 23361, 23371]
 [6, 9, 15, 16, 27, 30, 31, 40, 41, 45  …  23325, 23330, 23331, 23332, 23334, 23335, 23339, 23345, 23346, 23363]
 [3, 4, 5, 13, 19, 24, 32, 33, 34, 38  …  23348, 23349, 23350, 23369, 23370, 23372, 23373, 23374, 23375, 23376]</code></pre><h4 id="Visualization-of-the-historical-sequences-of-hidden-states"><a class="docs-heading-anchor" href="#Visualization-of-the-historical-sequences-of-hidden-states">Visualization of the historical sequences of hidden states</a><a id="Visualization-of-the-historical-sequences-of-hidden-states-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-the-historical-sequences-of-hidden-states" title="Permalink"></a></h4><pre><code class="language-julia hljs">year_range = unique(year.(data_stations[1][1+local_order:end, :DATE]));

idx_year = [findall(x -&gt; year.(x) == m, data_stations[1][1+local_order:end, :DATE]) for m in year_range];

select_year = unique(sort([4:10:length(year_range); 21; 48; 64]))

begin
    year_nb = length(select_year)
    z_hat_mat = zeros(year_nb, 366)

    for (i, y) in enumerate(select_year)
        if isleapyear(year_range[y])
            z_hat_mat[i, :] = ẑ[idx_year[y]]
        else
            z_hat_mat[i, :] = [ẑ[idx_year[y]]; 0]
        end
    end
    thick = 1
    heatmap(z_hat_mat, colorbar=:none, c=my_palette(K), minorticks=:false, framestyle=:xbox, grid=:none, thickness_scaling=thick)
    xticks!(vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366), vcat(string.(monthabbr.(1:12)), &quot;&quot;), xlims=(0, 367), xtickfontsize=14 / thick, ytickfontsize=14 / thick)
    hline!((1:year_nb) .+ 0.5, c=:black, legend=:none, lw=4)
    ylims!(0.5, year_nb + 0.5)
    pviterbi = yticks!(1:year_nb, string.(year_range[select_year]), size=(1000, 600))
end</code></pre><img src="9b3d92c0.svg" alt="Example block output"/><h2 id="Adding-Rain-amounts-to-the-model"><a class="docs-heading-anchor" href="#Adding-Rain-amounts-to-the-model">Adding Rain amounts to the model</a><a id="Adding-Rain-amounts-to-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Rain-amounts-to-the-model" title="Permalink"></a></h2><h3 id="Marginal-distribution"><a class="docs-heading-anchor" href="#Marginal-distribution">Marginal distribution</a><a id="Marginal-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Marginal-distribution" title="Permalink"></a></h3><p>We fit the marginals of the rain amount <span>$R&gt;0$</span> at each station <span>$s$</span> and for each hidden state <span>$Z$</span> independently. We use a mixture of exponential functions</p><p class="math-container">\[g(r) = w \dfrac{e^{-{\frac {r}{\vartheta_1}}}}{\vartheta_1} + (1-w)  \dfrac{e^{-{\frac {r}{\vartheta_2}}}}{\vartheta_2}.\]</p><p>whose parameters <span>$w(t)$</span>, <span>$\vartheta_1(t)$</span> and <span>$\vartheta_2(t)$</span> are smooth periodic functions of the day of the year.</p><pre><code class="language-julia hljs">@time &quot;FitMLE RR&quot; mix_allE = fit_mle_RR.(data_stations_z, K, local_order, mix₀=StochasticWeatherGenerators.mix_ini(T));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FitMLE RR: 85.815842 seconds (335.78 M allocations: 47.635 GiB, 4.35% gc time, 4.84% compilation time)</code></pre><p>Thanks to <a href="https://github.com/JuliaStats/Distributions.jl/pull/1389">Distributions.jl PR #1389 (September 2nd, 2021)</a> and Julia multiple dispatch, the quantile function of Mixtures can be very efficiently computed.</p><h3 id="Rain-correlations"><a class="docs-heading-anchor" href="#Rain-correlations">Rain correlations</a><a id="Rain-correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-correlations" title="Permalink"></a></h3><p>We fit a Gaussian copula to each pair of stations for joint rainy days only.</p><p>!!! warning   For some hidden states corresponding to dry weather, it might happen that for some pair of stations, there are no simultaneous rain occurrences in a rain category <span>$Z = k$</span>.   In that case a <code>missing</code> coefficient is returned.</p><pre><code class="language-julia hljs">begin
    Σ²RR = cov_RR(data_stations_z, K)
    if K == 4
        Σ²RR[2][6, 3] = Σ²RR[4][6, 3]
        Σ²RR[2][3, 6] = Σ²RR[4][6, 3]
    end
    Σ²RR = convert.(Matrix{Float64}, Σ²RR)
end

if K == 4
    @warn &quot;For Embrun j=6 and Marignane j=3 the hidden state Z=2 and Z=4 are pretty similar (dry), so we replace the `missing` coefficient of Z=2 with the one of Z = 4&quot;
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: ΣS_k[2], CartesianIndex{2}[CartesianIndex(6, 3), CartesianIndex(3, 6)] are missing
└ @ StochasticWeatherGenerators ~/work/StochasticWeatherGenerators.jl/StochasticWeatherGenerators.jl/src/rain/correlations.jl:80
┌ Warning: For Embrun j=6 and Marignane j=3 the hidden state Z=2 and Z=4 are pretty similar (dry), so we replace the `missing` coefficient of Z=2 with the one of Z = 4
└ @ Main tuto_paper.md:473</code></pre><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><p>Now we are ready to generate samples from the SWG model.</p><p><code>Nb</code> is the number of realization</p><pre><code class="language-julia hljs">Nb = 1000</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000</code></pre><p>Sample the (seasonal) HMM model and output the sequence of hidden states and multi-site dry/wet.</p><pre><code class="language-julia hljs">begin
    zs = zeros(Int, N, Nb)
    ys = zeros(Bool, N, D, Nb)
    @time &quot;Simulations Z, Y&quot; for i in 1:Nb
        zs[:, i], ys[:, :, i] = rand(hmm_fit, n2t; y_ini=Yall[1:local_order, :], z_ini=1, seq=true)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulations Z, Y: 61.991649 seconds (328.73 M allocations: 32.194 GiB, 7.68% gc time, 1.29% compilation time)</code></pre><p>Given the hidden states and dry/wet, it generates the rain amounts at each station (correlated with a Gaussian Copula).</p><pre><code class="language-julia hljs">begin
    rs = zeros(D, N, Nb)
    @time &quot;Simulations RR&gt;0&quot; for i in 1:Nb
        rs[:, :, i] = rand_RR(mix_allE, n2t, zs[:, i], ys[:, :, i]&#39;, Σ²RR)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulations RR&gt;0: 231.564796 seconds (270.58 M allocations: 37.739 GiB, 1.68% gc time, 0.79% compilation time)</code></pre><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><h3 id="Spell-distribution"><a class="docs-heading-anchor" href="#Spell-distribution">Spell distribution</a><a id="Spell-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Spell-distribution" title="Permalink"></a></h3><p><code>select_month</code> to choose the month where to compute the spell distributions (summer month, winter, etc.) <code>select_month = 1:12</code> corresponds to all months.</p><pre><code class="language-julia hljs">select_month = 1:12

idx_months = [findall(x -&gt; month.(x) == m, data_stations[1][1+local_order:end, :DATE]) for m in 1:12]

idx_month_vcat = vcat(idx_months[select_month]...)

idx_all = [intersect(yea, mon) for yea in idx_year, mon in idx_months];</code></pre><h5 id="Historic-spells"><a class="docs-heading-anchor" href="#Historic-spells">Historic spells</a><a id="Historic-spells-1"></a><a class="docs-heading-anchor-permalink" href="#Historic-spells" title="Permalink"></a></h5><pre><code class="language-julia hljs">len_spell_hist = [pmf_spell(Y[idx_month_vcat, j], dw) for j in 1:D, dw in 0:1];</code></pre><h5 id="Simulation-spells"><a class="docs-heading-anchor" href="#Simulation-spells">Simulation spells</a><a id="Simulation-spells-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-spells" title="Permalink"></a></h5><pre><code class="language-julia hljs">len_spell_simu = [pmf_spell(ys[idx_month_vcat, j, i], dw) for i in 1:Nb, j in 1:D, dw in 0:1];</code></pre><h4 id="Dry-spell"><a class="docs-heading-anchor" href="#Dry-spell">Dry spell</a><a id="Dry-spell-1"></a><a class="docs-heading-anchor-permalink" href="#Dry-spell" title="Permalink"></a></h4><pre><code class="language-julia hljs">make_range(y, step=1) = range(extrema(y)..., step=step)

begin
    dry_or_wet = 1 # dry
    p_spell_dry = [plot(ylims=(1e-4, 1e-0), tickfont=11, legendfontsize=13) for j = 1:D]
    for j = 1:D
        all_spells = len_spell_simu[:, j, dry_or_wet]
        errorlinehist!(p_spell_dry[j], all_spells, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median)

        errorlinehist!(p_spell_dry[j], all_spells, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median)

        histo_spell = len_spell_hist[j, dry_or_wet]
        errorlinehist!(p_spell_dry[j], [histo_spell], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:probability, bins=make_range(histo_spell), errortype=:percentile)
        xlims!(p_spell_dry[j], 0, 2 + maximum(1.5maximum.(histo_spell)))
        yaxis!(:log10)
    end

    [xlabel!(p_spell_dry[j], &quot;Nb of days&quot;, xlabelfontsize=12) for j in staid_lat[6:10]]
    [ylabel!(p_spell_dry[j], &quot;PMF&quot;, ylabelfontsize=12) for j in staid_lat[[1, 6]]]
    [title!(p_spell_dry[j], station_name[j], titlefontsize=13) for j = 1:D]
    pall_spell_dry = plot(p_spell_dry[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), left_margin=0.5cm, bottom_margin=0.275cm)
end</code></pre><img src="f56b5a89.svg" alt="Example block output"/><h4 id="Wet-spell"><a class="docs-heading-anchor" href="#Wet-spell">Wet spell</a><a id="Wet-spell-1"></a><a class="docs-heading-anchor-permalink" href="#Wet-spell" title="Permalink"></a></h4><pre><code class="language-julia hljs">begin
    dry_or_wet = 2 # wet
    p_spell_wet = [plot(ylims=(1e-4, 1e-0), tickfont=11, legendfontsize=13) for j = 1:D]
    for j = 1:D
        all_spells = len_spell_simu[:, j, dry_or_wet]
        errorlinehist!(p_spell_wet[j], all_spells, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median)

        errorlinehist!(p_spell_wet[j], all_spells, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:probability, bins=make_range(reduce(vcat, all_spells)), errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median)

        histo_spell = len_spell_hist[j, dry_or_wet]
        errorlinehist!(p_spell_wet[j], [histo_spell], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:probability, bins=make_range(histo_spell), errortype=:percentile)
        xlims!(p_spell_wet[j], 0, 2 + maximum(1.5maximum.(histo_spell)))
        yaxis!(:log10)
    end

    [xlabel!(p_spell_wet[j], &quot;Nb of days&quot;, xlabelfontsize=12) for j in staid_lat[6:10]]
    [ylabel!(p_spell_wet[j], &quot;PMF&quot;, ylabelfontsize=12) for j in staid_lat[[1, 6]]]
    [title!(p_spell_wet[j], station_name[j], titlefontsize=13) for j = 1:D]
    pall_spell_wet = plot(p_spell_wet[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), left_margin=0.5cm, bottom_margin=0.275cm)
end</code></pre><img src="97694708.svg" alt="Example block output"/><h3 id="Rain"><a class="docs-heading-anchor" href="#Rain">Rain</a><a id="Rain-1"></a><a class="docs-heading-anchor-permalink" href="#Rain" title="Permalink"></a></h3><h4 id="Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k."><a class="docs-heading-anchor" href="#Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k.">Interpretation: Mean Rain per weather regime <span>$R &gt; 0 \mid Z = k$</span>.</a><a id="Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k.-1"></a><a class="docs-heading-anchor-permalink" href="#Interpretation:-Mean-Rain-per-weather-regime-R-0-\\mid-Z-k." title="Permalink"></a></h4><p>We plot the empirical (strictly) positive <strong>mean</strong> rain amounts per weather regime. The results are smoothed using a <code>cyclic_moving_average</code> with a time window of <span>$\pm 15$</span> days and the Epanechnikov kernel.</p><pre><code class="language-julia hljs">begin
    p_rainpercat = [plot(tickfont=12, ylabelfontsize=14, titlefontsize=14, legendfontsize=13) for j = 1:D]
    for j = 1:D
        df_j = @chain data_stations_z[j] begin
            dropmissing
            @transform(:day = dayofyear_Leap.(:DATE))
            @subset(:RR .&gt; 0)
            @by([:day, :z], :MEAN_RR = mean(:RR))
            groupby(:z)
        end
        # Uncomment to see how the double exponential mixtures compare to the empirical data.
        # [plot!(p_rainpercat[j], 1:T, t -&gt; conversion_factor * mean(mix_allE[j][k, t]), label=:none, c=my_color(k, K), lw=1.5, legend = :topleft) for k in 1:K]
        for k in 1:K
            cycle_avg = replace(cyclic_moving_average(df_j[k].MEAN_RR, df_j[k].day, T, 15), 0 =&gt; missing)
            @df df_j[k] plot!(p_rainpercat[j], 1:T, conversion_factor * cycle_avg, c=my_color(k, K), alpha=1, label=islabel(j, staid_lat[[4]], L&quot;Z = %$k&quot;), lw=1.5)
        end
        ylims!(p_rainpercat[j], 0, Inf)
    end
    [ylabel!(p_rainpercat[j], L&quot;Rain (mm/m$^2$)&quot;) for j in staid_lat[[1, 6]]]
    [xticks!(
        p_rainpercat[j],
        vcat(dayofyear_Leap.(Date.(2000, 1:12)), 366),
        vcat(string.(first.(string.(monthabbr.(1:12)))))
    ) for j in 1:D]
    [title!(p_rainpercat[j], station_name[j]) for j = 1:D]
    plt_rain_cat_mix = plot(p_rainpercat[staid_lat]..., size=(3000 / 2.2, 1000 / 1.5), layout=(2, 5), left_margin=25px)
end</code></pre><img src="6332b66a.svg" alt="Example block output"/><h4 id="Univariate-Rain-distributions"><a class="docs-heading-anchor" href="#Univariate-Rain-distributions">Univariate Rain distributions</a><a id="Univariate-Rain-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Rain-distributions" title="Permalink"></a></h4><p>Historical vs Nb simulations distribution</p><pre><code class="language-julia hljs">begin
    p_uniR = [plot(yaxis=:log10, ylims=(1e-4, 1e-0), tickfont=11, legendfontsize=13, titlefontsize=13) for j = 1:D]
    for j = 1:D
        dists_RR_positive_j = conversion_factor * [filter(!iszero, rs[j, :, i]) for i in 1:Nb]
        errorlinehist!(p_uniR[j], dists_RR_positive_j, groupcolor=:grey, legend=:topright, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{0,100}$&quot;), norm=:pdf, errortype=:percentile, percentiles=[0, 100], fillalpha=0.4, centertype=:median)

        errorlinehist!(p_uniR[j], dists_RR_positive_j, groupcolor=:red, label=islabel(j, staid_lat[[1]], L&quot;Simu $q_{25,75}$&quot;), norm=:pdf, errortype=:percentile, percentiles=[25, 75], fillalpha=0.5, centertype=:median)

        errorlinehist!(p_uniR[j], [conversion_factor * filter(!iszero, data_stations[j].RR)], label=islabel(j, staid_lat[[1]], &quot;Obs&quot;), groupcolor=:blue, lw=1.5, norm=:pdf, errortype=:percentile)

        xlims!(p_uniR[j], 0.0, Inf)
    end
    [plot!(p_uniR[j], xlabel=L&quot;Rain (mm/m$^2$)&quot;) for j in staid_lat[6:10]]
    [plot!(p_uniR[j], ylabel=&quot;PDF&quot;) for j in staid_lat[[1, 6]]]

    [title!(p_uniR[j], station_name[j]) for j = 1:D]

    pall_R = plot(p_uniR[staid_lat]..., size=(3000 / 2.5, 1000 / 1.5), layout=(2, 5), bottom_margin=11px, left_margin=15px)
end</code></pre><img src="9da88a9c.svg" alt="Example block output"/><h4 id="Monthly-quantile-amount"><a class="docs-heading-anchor" href="#Monthly-quantile-amount">Monthly quantile amount</a><a id="Monthly-quantile-amount-1"></a><a class="docs-heading-anchor-permalink" href="#Monthly-quantile-amount" title="Permalink"></a></h4><pre><code class="language-julia hljs">rh = reduce(hcat, [df[1+local_order:end, :RR] for df in data_stations])

month_rain_simu = [cum_monthly(rs[j, :, i], idx_all) for j in 1:D, i in 1:Nb];

month_rain_histo = [cum_monthly(rh[:, j], idx_all) for j in 1:D]

qs = [0.9, 0.5, 0.1]

@time &quot;Plot monthly quantile&quot; begin
    p_month_RR = [scatter(xtickfontsize=10, ytickfontsize=11, ylabelfontsize=12, legendfontsize = 12, foreground_color_legend=nothing) for j = 1:D]
    for j = 1:D
        for (α, per) in enumerate([[0, 100], [25, 75]])
            for (cc, q) in enumerate(qs)
                errorline!(p_month_RR[j], [quantile(month_rain_simu[j, i][:, m], q) * conversion_factor for m in 1:12, i in 1:Nb], label=(α == 1 ? islabel(j, 9,L&quot;Simu  $q_{%$(Int(q*100))}$&quot;) : :none), fillalpha=0.18 * α^2, centertype=:median, errortype=:percentile, percentiles=per, groupcolor=my_palette(length(qs))[cc])
            end
        end
        for q in qs
            scatter!(p_month_RR[j], m -&gt; quantile(month_rain_histo[j][:, m], q) * conversion_factor, 1:12, label=(q == qs[1] ? islabel(j, 3,&quot;Obs&quot;) : :none), legend = :topleft, ms=2.5, c=:blue)
            plot!(p_month_RR[j], m -&gt; quantile(month_rain_histo[j][:, m], q) * conversion_factor, 1:12, label=:none, c=:blue, lw=1.75)
        end
        xticks!(p_month_RR[j], 1:12, string.(first.(monthabbr.(1:12))))
        ylims!(p_month_RR[j], 0, Inf)
    end
    [ylabel!(p_month_RR[j], L&quot;Rain (mm/m$^2$)&quot;) for j in staid_lat[[1, 6]]]

    [title!(p_month_RR[j], station_name[j], titlefontsize=12) for j = 1:D]
    pall_month_RR = plot(p_month_RR[staid_lat]..., size=(1190, 500), layout=(2, 5), left_margin=19px)
end</code></pre><img src="7b0ed3af.svg" alt="Example block output"/><h3 id="Correlations"><a class="docs-heading-anchor" href="#Correlations">Correlations</a><a id="Correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Correlations" title="Permalink"></a></h3><h5 id="Rain-event-dry/wet"><a class="docs-heading-anchor" href="#Rain-event-dry/wet">Rain event dry/wet</a><a id="Rain-event-dry/wet-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-event-dry/wet" title="Permalink"></a></h5><pre><code class="language-julia hljs">cor_bin_hist = cor(reduce(hcat, [df.bin for df in data_stations]));

cor_bin_mean_simu = mean(cor(ys[:, :, i]) for i in 1:Nb);


begin
    plots_cor_bin = [plot(-0.1:0.1:0.8, -0.1:0.1:0.8, aspect_ratio=true, label=:none, xlabelfontsize=16, ylabelfontsize=16, tickfont=11, legendfontsize=13) for _ in 1:1]
    scatter!(plots_cor_bin[1], vec_triu(cor_bin_hist), vec_triu(cor_bin_mean_simu), label=&quot;Correlations&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=2)
    [xlims!(plots_cor_bin[i], -0.1, 1) for i in 1:1]
    [ylims!(plots_cor_bin[i], -0.1, 1) for i in 1:1]
    annotate!(0.2, 0.7, &quot;MSE ≃ $(round(mean(abs2, vec_triu(cor_bin_hist) - vec_triu(cor_bin_mean_simu)), digits = 4))&quot;)
    plot_cor_bin = plot(plots_cor_bin...)
end</code></pre><img src="04f1a8c1.svg" alt="Example block output"/><p>The largest pair correlation error for rain occurence comes from the pair</p><pre><code class="language-julia hljs">println(&quot;$(station_name[findmax(cor_bin_hist - cor_bin_mean_simu)[2][1]]) and $(station_name[findmax(cor_bin_hist - cor_bin_mean_simu)[2][2]])&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CHASSIRON and LA HAGUE</code></pre><h5 id="Rain-amount"><a class="docs-heading-anchor" href="#Rain-amount">Rain amount</a><a id="Rain-amount-1"></a><a class="docs-heading-anchor-permalink" href="#Rain-amount" title="Permalink"></a></h5><pre><code class="language-julia hljs">cor_hist = cor(reduce(hcat, [df.RR for df in data_stations]));

corT_hist = corTail(reduce(hcat, [df.RR for df in data_stations]));

cor_mean_simu = mean(cor(rs[:, :, i]&#39;) for i in 1:Nb);

corT_mean_simu = mean(corTail(rs[:, :, i]&#39;) for i in 1:Nb);

begin
    plots_cor = [plot(-0.1:0.1:0.8, -0.1:0.1:0.8, aspect_ratio=true, label=:none, xlabelfontsize=16, ylabelfontsize=16, tickfont=11, legendfontsize=13) for _ in 1:2]
    scatter!(plots_cor[1], vec_triu(cor_hist), vec_triu(cor_mean_simu), label=&quot;Correlations&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=2)
    annotate!(plots_cor[1], 0.3, 0.7, &quot;MSE ≃ $(round(mean(abs2, vec_triu(cor_hist) - vec_triu(cor_mean_simu)), digits = 4))&quot;)

    scatter!(plots_cor[2], vec_triu(corT_hist), vec_triu(corT_mean_simu), label=&quot;Tail index&quot;, xlabel=&quot;Observations&quot;, ylabel=&quot;Simulations&quot;, c=3)
    annotate!(plots_cor[2], 0.3, 0.7, &quot;MSE ≃ $(round(mean(abs2, vec_triu(corT_hist) - vec_triu(corT_mean_simu)), digits = 4))&quot;)

    [xlims!(plots_cor[i], -0.1, 1) for i in 1:2]
    [ylims!(plots_cor[i], -0.1, 1) for i in 1:2]
    plot(plots_cor..., size=(800, 400), left_margin=15px)
end</code></pre><img src="d490bc4e.svg" alt="Example block output"/><p>The largest pair correlation error for rain (zero and non zero amounts) comes from the pair</p><pre><code class="language-julia hljs">println(&quot;$(station_name[findmax(cor_hist - cor_mean_simu)[2][1]]) and $(station_name[findmax(cor_hist - cor_mean_simu)[2][2]])&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EMBRUN and MARIGNANE</code></pre><h5 id="Gaussian-copula-hypothesis"><a class="docs-heading-anchor" href="#Gaussian-copula-hypothesis">Gaussian copula hypothesis</a><a id="Gaussian-copula-hypothesis-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-copula-hypothesis" title="Permalink"></a></h5><p>For a pair of stations, we transform the marginal <span>$R_s&gt;0$</span> to <span>$\mathcal{N}(0,1)$</span>. We compare the obtained bi-variate Normal distribution with the Mahalanobis distance to the theoretical <span>$\chi^2(2)$</span>-distriubtion.</p><pre><code class="language-julia hljs">corΣ = cov2cor.(Σ²RR)
begin
    j1 = 10
    j2 = 8
    plt_qqp_copula = plot(0:25, 0:25, aspect_ratio=:equal, legendfontsize=14, c=:black, label=:none, tickfont=12, ylabelfontsize=13, xlabelfontsize=13)
    df_12 = leftjoin(data_stations_z[j1], data_stations_z[j2], on=:DATE, makeunique=true)
    @subset!(df_12, :RR .&gt; 0, :RR_1 .&gt; 0)
    for k in 1:K
        df_X = @chain df_12 begin
            @subset(:z .== k)
            dropmissing
            @aside u = StochasticWeatherGenerators.Copulas.pseudos(permutedims(hcat(_.RR, _.RR_1)))
            @transform(:X = quantile(Normal(), u[1,:]), :X_1 = quantile(Normal(), u[2,:]))
        end
        X = hcat(df_X.X, df_X.X_1)
        cor_sigma = [1 corΣ[k][j1,j2]; corΣ[k][j1,j2] 1]
        Σ⁻¹ = inv(cor_sigma)

        X2 = [(x&#39; * Σ⁻¹ * x) for x in eachrow(X)] |&gt; sort
        ecdfX2 = ecdf(X2)(X2) * length(X2) / (length(X2) + 1)

        plot!(quantile(Chisq(2), ecdfX2), X2, xlabel=L&quot;$\chi^2(2)$-quantile&quot;, c=my_color(k, K), ylabel=&quot;Observed squared Mahalanobis distance&quot;, label=L&quot;Z = %$k &quot;, legend=:topleft, lw=2)
    end
    title!(&quot;$(station_name[j1]) vs $(station_name[j2])&quot;)
    xlims!(0, 22)
    ylims!(0, 22)
end</code></pre><img src="97384532.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« StochasticWeatherGenerators.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 13 September 2024 14:10">Friday 13 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
